<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="JohnPaul Adamovsky">
<title>Directed Acyclic Word Graph or DAWG</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge {
  color: #faf6e4;
  background-color: #122b3b;
}
pre.rouge .gl {
  color: #dee5e7;
  background-color: #4e5d62;
}
pre.rouge .gp {
  color: #a8e1fe;
  font-weight: bold;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6c8b9f;
  font-style: italic;
}
pre.rouge .cp {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .err {
  color: #fefeec;
  background-color: #cc0000;
}
pre.rouge .gr {
  color: #cc0000;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kv {
  color: #f6dd62;
  font-weight: bold;
}
pre.rouge .o, pre.rouge .ow {
  color: #4df4ff;
  font-weight: bold;
}
pre.rouge .p, pre.rouge .pi {
  color: #4df4ff;
}
pre.rouge .gd {
  color: #cc0000;
}
pre.rouge .gi {
  color: #b2fd6d;
}
pre.rouge .ge {
  font-style: italic;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gt {
  color: #dee5e7;
  background-color: #4e5d62;
}
pre.rouge .kc {
  color: #f696db;
  font-weight: bold;
}
pre.rouge .kn {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .gh {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .gu {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .no {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .nc {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .nd {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .nn {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .bp {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .ne {
  color: #b2fd6d;
  font-weight: bold;
}
pre.rouge .nl {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .nt {
  color: #ffb000;
  font-weight: bold;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #f696db;
  font-weight: bold;
}
pre.rouge .ld {
  color: #f696db;
  font-weight: bold;
}
pre.rouge .ss {
  color: #f696db;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sb, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .sh, pre.rouge .sx, pre.rouge .sr, pre.rouge .s1 {
  color: #fff0a6;
  font-weight: bold;
}
pre.rouge .sa {
  color: #f6dd62;
  font-weight: bold;
}
pre.rouge .se {
  color: #4df4ff;
  font-weight: bold;
}
pre.rouge .sc {
  color: #4df4ff;
  font-weight: bold;
}
pre.rouge .si {
  color: #4df4ff;
  font-weight: bold;
}
pre.rouge .nb {
  font-weight: bold;
}
pre.rouge .ni {
  color: #999999;
  font-weight: bold;
}
pre.rouge .w {
  color: #BBBBBB;
}
pre.rouge .go {
  color: #BBBBBB;
}
pre.rouge .nf, pre.rouge .fm {
  color: #a8e1fe;
}
pre.rouge .py {
  color: #a8e1fe;
}
pre.rouge .na {
  color: #a8e1fe;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #a8e1fe;
  font-weight: bold;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Directed Acyclic Word Graph or DAWG</h1>
<div class="details">
<span id="author" class="author">JohnPaul Adamovsky</span><br>
<span id="email" class="email"><a href="mailto:logarithm69@hotmail.com">logarithm69@hotmail.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#blitzkrieg_attack_algorithm">Blitzkrieg Attack Algorithm</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#structure">The Blitzkrieg DAWG Structure</a></li>
<li><a href="#creation">Blitzkrieg DAWG Genesis</a></li>
<li><a href="#implement">C &amp; Java Implementation</a></li>
<li><a href="#commented-code">Commented C-code</a>
<ul class="sectlevel2">
<li><a href="#blitzkrieg_dawg_creator">Blitzkrieg DAWG Creator</a></li>
<li><a href="#blitzkrieg_functionality_test">Blitzkrieg Functionality Test</a></li>
</ul>
</li>
<li><a href="#contact">Contact Information</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="blitzkrieg_attack_algorithm"><a class="anchor" href="#blitzkrieg_attack_algorithm"></a>Blitzkrieg Attack Algorithm</h2>
<div class="sectionbody">
<div class="paragraph text-center">
<p>474 KB Compressed-Postfix Boolean-Word-Graph For The English Language</p>
</div>
<div class="paragraph">
<p>6 Major Concerns Addressed On:  Monday, December 30, 2011.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>First Concern:</strong> A user defined character set of up to 256 letters is now supported.
This accomodates certain foreign lexicons.</p>
</li>
<li>
<p><strong>Second Concern:</strong> Allowance for medium sized word lists.
2^22 (4,194,304) DAWG-Node count is the new upper limit.</p>
</li>
<li>
<p><strong>Third Concern:</strong> Superior &#8220;ReplaceMeWith&#8221; scheme.</p>
</li>
<li>
<p><strong>Fourth Concern:</strong> The use of CRC-Digest calculation, &#8220;Tnode&#8221; segmentation, and stable group sorting render DAWG creation <strong>INSTANTANEOUS</strong>.
The Blitzkrieg algorithm generates a DAWG encoding so fast, that it might very well already be a Google trade secret, the kind of performance one might come to expect if you found a way to get Ken Thompson, Dennis Ritchie, and even the Great John von Neumann to build it for you.</p>
</li>
<li>
<p><strong>Fifth Concern:</strong> Certain Graph configurations led the previous version of this program to crash&#8230;&#8203; <strong>NO MORE</strong>.</p>
</li>
<li>
<p><strong>Sixth Concern:</strong> A new DAWG int-node format is used to reduce the number of bitwise operations + add direct &#8220;char&#8221; extraction.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This algorithm is dedicated to Michael Czajka, a talented colleague, and fallen comrade.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="acknowledgments"><a class="anchor" href="#acknowledgments"></a>Acknowledgments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to the following programmers for their input:</p>
</div>
<div class="paragraph">
<p><strong>Rasmus Andersson</strong>&#8201;&#8212;&#8201;Motivated me to code the Blitzkrieg Algorithm when he found a wordlist which crashed the Traditional_Dawg_Creator code.</p>
</div>
<div class="paragraph">
<p><strong>Jerzy Chalupski</strong>&#8201;&#8212;&#8201;Alerted me to the potential of how CRC calculation could boost speed during the graph reduction analysis.
This is his object oriented C++ documentation; <a href="https://github.com/chalup/dawggenerator" class="bare">https://github.com/chalup/dawggenerator</a>.
It&#8217;s not going to win him the Nobel Prize, but he must be doing something right, because the CRC idea is magnificent.</p>
</div>
<div class="paragraph">
<p><strong>Edouard de Labareyre</strong>&#8201;&#8212;&#8201;Questions about French words.
<strong>Joakim Laumann</strong>&#8201;&#8212;&#8201;Questions about Norwegian words.
<strong>Oskar Groth</strong>&#8201;&#8212;&#8201;Questions about Swedish words.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The next program I write will use what I have learned here to solve a high profile NP-Complete problem.
With this type of accomplishment, I hope to bypass the multi-phase Google interview process, and conduct a single Pow-Wow interview session with Ken Thompson, Google&#8217;s Most Distinguished Engineer.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A directed acyclic word graph is simply a data structure that stores a lexicon of character strings or words in a compressed array of properly encoded integers.
It is a great place to begin an investigation of lexicon-data-structure optimization, but ultimately, the traditional DAWG&#8217;s limitations due to list-scrolling and Boolean return values will lead the elite-optimization-programmer to the more advanced
<a href="https://pages.pathcom.com/~vadco/cwg.html" title="Caroline Word Graph or CWG" target="_blank" rel="noopener">Caroline Word Graph</a>.
Any process that makes use of the
<a href="https://en.wikipedia.org/wiki/Directed_acyclic_word_graph" title="Wikipedia on directed acyclic word graph (DAWG)" target="_blank" rel="noopener">DAWG</a>
data structure traverses it as though it were a list-style trie.
A <a href="https://en.wikipedia.org/wiki/Trie" title="Learn more about the Trie data structure" target="_blank" rel="noopener">TRIE</a>
is a data tree where every prefix is shared to reduce the amount of space required to store a lexicon and reduce the time required to &#8220;retrieve&#8221; a word.
A Trie using explicit pointers, for each child node, becomes something like an enormous sparse matrix, populated mostly with zeros.
Progression to a list-style Trie reduces the structure&#8217;s size and retains the added benefit of a one-to-one ratio between words and End_Of_Word_Flags.
The compromise is that finding a child node requires scrolling through a list of nodes.
The DAWG data structure results from an attempt to reduce the size of a list-style Trie while maintaining the fast search times.
This is carried out by attempting to replace identical postfix structures.
It is critical to understand that all words ending with an &#8220;s&#8221; or &#8220;es&#8221; or &#8220;tion&#8221; or &#8220;istic&#8221; do NOT necessarily use the same nodes in the DAWG data structure.
The example below will clarify this salient DAWG-property:</p>
</div>
<div class="paragraph">
<p>Consider the trie of 11 words stored in 23 nodes:</p>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="olist arabic">
<ol class="arabic">
<li>
<p>ablate</p>
</li>
<li>
<p>ablated</p>
</li>
<li>
<p>ablates</p>
</li>
<li>
<p>ablating</p>
</li>
<li>
<p>ablation</p>
</li>
<li>
<p>ablations</p>
</li>
<li>
<p>abject</p>
</li>
<li>
<p>abjection</p>
</li>
<li>
<p>abjections</p>
</li>
<li>
<p>abjectly</p>
</li>
<li>
<p>abjectness</p>
</li>
</ol>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="image"><img src="data:image/png;base64,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" alt="DAWG Example" width="60%"></span></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>It can be clearly observed that because there is no &#8220;e&#8221; following the &#8220;t&#8221; in &#8220;abject,&#8221; the &#8220;t&#8221; contained in &#8220;ablate&#8221; can not be the same node in a DAWG.
Hence the &#8220;tion&#8221; shared by each word does not share the same postfix structure, and must not be the same path in the DAWG.
It is true however that the &#8220;ons&#8221; structure will be shared by both words in a DAWG.
That is only true for the optimal DAWG because the &#8220;ons&#8221; part of &#8220;abjections&#8221; is a direct child.
A graphical representation is presented above.
It is not computer generated.</p>
</div>
<div class="paragraph">
<p>Due to the objective of space reduction being the essence of a DAWG, it is important to note that the minimal number of nodes will not produce the smallest DAWG.
Space size of a data structure is given by the following equation:</p>
</div>
<div class="paragraph text-center">
<p>STRUCTURE SIZE = (NUMBER OF NODES) x (SIZE OF EACH NODE)</p>
</div>
<div class="paragraph">
<p>The size of each node in computer science is not arbitrary.
Data structures have a minimum unit size of 4-Bytes, and there are 1-Byte and 2-Byte basic integer types as well, but 3-Byte basic integer types do not exit.
Standard C treats this as divine truth.
Therefore if the size of each node can be reduced by half and the number of nodes does not double as a result, the total structure size has fallen.
Replacing the Trie&#8217;s Next pointer with breadth-first array population and a single Bit-Flag is why a DAWG-Node can fit into one 32-Bit integer.
It is unfortunate that 3-Byte integers are not supported by modern processor architectures, because for TWL06, each int-node can be squeezed into 3-Bytes.
There are 2 ways to make this happen even still, but they both require additional bit-manipulation instructions, so they can hardly be justified:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The DAWG structure can be housed in an array of short integers plus an array of chars.
In this scheme, the first-child index value would span into both parts of the structure, and so additional masking and shifting would be required to extract information from each node.
If the number of nodes in your DAWG can fit into 16 bits, then this 3-Byte segmentation is the way to go.</p>
</li>
<li>
<p>The DAWG structure can be housed in one array of chars.
In this scheme, indexing each node in the structure requires multiplying by 3, which can be accomplished by the following equation: <code>Index = Index&lt;&lt;1 + Index;</code> Integer casting is then needed, as well as one additional bit-mask.
The one equation involves 2 basic operations plus an assignment, so although you are saving 25% in data space, you are paying for it in extra instructions.
If your processor is either lacking in data cache, or it contains native 3-Byte hardware instructions, then this is the way to go, otherwise avoid the additional computation.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="structure"><a class="anchor" href="#structure"></a>The Blitzkrieg DAWG Structure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A DAWG-Node can be seen as containing a letter, references to its children, and a Flag indicating the completion of a word.
Now, because a single character does not represent an entire word, or key, computer science would not refer to (a single letter, a flag, and pointers) as a &#8220;node&#8221;.
Rather, each character would be called an &#8220;edge&#8221;.
In order to simplify this DAWG treatment, the &#8220;edge&#8221; convention has been disposed of.
A node in a DAWG is now defined as &#8220;an Explicit-Letter, an index to the First-Child node, an End-Of-Word flag, and an End-Of-List flag&#8221;.</p>
</div>
<div class="paragraph">
<p>We are attempting to minimize the size of a single &#8220;node&#8221; so that it will be less than or equal to 32 bits while at the same time keeping the number of nodes low enough to justify the reduction of information in each node.
For now, this is a double-edged sword, because it forces graph traversal to scroll through Child-Lists.</p>
</div>
<div class="paragraph">
<p>In short, the 26 letters in the English alphabet require 5-bits to store a Letter-Index, but since the space is available, we shall use a full 8-Bit Byte to store an Explicit-Letter, with the potential to accommodate languages with up to 256 unique characters.
Additionally, no extra instruction will be needed to turn a Letter-Index into a usable char.
Nodes need a single bit to store an End-Of-Word flag.
A list of children should make sense because this would reduce the number of references for children to just two.
One reference is for the First-Child of the list below a node, and a second reference is for Next-Node in the current list.</p>
</div>
<div class="paragraph">
<p>Experimentation has shown that there is one further reduction that will ultimately reduce the size of the final DAWG, but increase the number of nodes slightly.
The DAWG nodes will be stored into a contiguous array, where the Next-Node reference will be replaced by a single End-Of-List bit-flag, where the Next-Node in a list is assumed to be the next element in the array unless the End-Of-List bit-flag is set.
This will increase the total number of nodes required because the only DirectChild nodes will be tested for emilination, to keep the list structures intact, in other words, the first node in a Child-List is the only type of node where elimination can begin.
Clearly, every node in the Next-List and every node below a redundant node will also be removed, so there will not be as much of a discrepancy in node elimination as one would expect, given this strict condition.</p>
</div>
<div class="paragraph">
<p>This &#8220;Child Reference Only&#8221; step is far from trivial, as it requires a &#8220;breadth&#8221; first tree traversal.
This type of traversal is required to enter all of the temporary Tnodes into a 4D array which holds similar groups of pointers which will be sorted using 3 comparison values.
Also, this type of traversal is required once more when assigning indexes to all of the remaining Tnodes.
Complexity arises from the requirement of a secondary data structure know as a queue, so that traversal is carried out level by level, as opposed to the standard recursive &#8220;depth-first&#8221; traversal.</p>
</div>
<div class="paragraph">
<p>With ten bits spoken for, that leaves 22 bits remaining for the First-Child index.
22-Bits translates into a maximum number of array elements equal to 4,194,304.
This value exceeds the number of nodes needed to store TWL06 by a large margin.
TWL06 fits into 121,174 nodes (including the Null zero node), which requires only 17-bits.
This number only reaches 123,670 nodes using a less complex algorithm, which used to be presented on this very page.
Every node is a 4-Byte integer, so that is where 474 KB, presented above, comes from.
At less than a half Mega Byte to store a fast Boolean graph of the English Language, the traditional DAWG encoding has its appeal.
It would require almost double this space to store a DAWG with a minimal node count.
Learn this data structure, and then migrate to the more advanced <a href="https://pages.pathcom.com/~vadco/cwg.html" title="Caroline Word Graph or CWG" target="_blank" rel="noopener">Caroline Word Graph</a>.</p>
</div>
<div class="paragraph">
<p>The Blitzkrieg encoding places an Explicit-Letter into the first Byte of each Node-Integer, followed by the End-Of-List flag, followed by the End-Of-Word flag, and the final 22 most significant bits hold the First-Child index value, which can now be extracted using a single Bit-Shift.
Below, I have included a printout of what each int-node looks like and the macros used to extract member data from them.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[1111111111111111111111|0|0|00000000] - CHILD_INDEX_BIT_MASK
[0000000000000000000000|1|0|00000000] - END_OF_WORD_BIT_MASK
[0000000000000000000000|0|1|00000000] - END_OF_LIST_BIT_MASK
[0000000000000000000000|0|0|11111111] - LETTER_BIT_MASK</pre>
</div>
</div>
<div class="listingblock small">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#define CHILD_BIT_SHIFT 10
#define EOW_BIT_MASK 0X00000200
#define EOL_BIT_MASK 0X00000100
#define LETTER_BIT_MASK 0X000000FF</span></code></pre>
</div>
</div>
<div class="listingblock small">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#define DAWG_LETTER(thearray, theindex) (thearray[theindex]&amp;LETTER_BIT_MASK)
#define DAWG_EOW(thearray, theindex) (thearray[theindex]&amp;EOW_BIT_MASK)
#define DAWG_NEXT(thearray, theindex) ((thearray[theindex]&amp;EOL_BIT_MASK)? 0: theindex + 1)
#define DAWG_CHILD(thearray, theindex) (thearray[theindex]&gt;&gt;CHILD_BIT_SHIFT)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creation"><a class="anchor" href="#creation"></a>Blitzkrieg DAWG Genesis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When creating a DAWG encoding with the Blitzkrieg_Trie_Attack algorithm, it will seem as though you have activated a time machine and transported the new DAWG data file into the PAST.
Yes, the Blitzkrieg algorithm is that much faster than the older versions of Traditional_Dawg_Creator code, which took several minutes to compute TWL06 using even a 3Ghz multi-core PC.
The 17 steps are listed below.
<a href="#commented-code">Commented C-code</a> is also provided, and will assist anyone who is interested in understanding how these steps actually work.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Step 0:</strong>  Allocate the framework for the intermediate Array-Data-Structure.</p>
</li>
<li>
<p><strong>Step 1:</strong>  Create a temporary list-style Trie and begin filling it with the words from &#8220;<code>Word-List.txt</code>&#8221;.</p>
</li>
<li>
<p><strong>Step 2:</strong>  Calculate the InternalValues comparison integers for each Tnode.</p>
<div class="ulist">
<ul>
<li>
<p>The InternalValues integer contains all of the unique internal comparison values of each Tnode in one number.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Step 3:</strong>  Eliminate recursion by calculating the recursive CrcDigest for each Tnode.</p>
<div class="ulist">
<ul>
<li>
<p>The CrcDigest value is calculated by using the InternalValues of each Tnode, and then building a longer data-message with information gathered from all Child nodes and Next nodes, seperated by pre-defined cypher integers.
Tnodes without any Child or Next lists simply copy their InternalValues into their CrcDigest.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Step 4:</strong>  Count Tnodes into 780 groups, segmented by MaxChildDepth, Letter, and DirectChild.</p>
</li>
<li>
<p><strong>Step 5:</strong>  Initial Tnode counting is complete, so display the results:</p>
</li>
<li>
<p><strong>Step 6:</strong>  Allocate a 4-D array of Tnode pointers to tag redundant Tnodes for replacement.</p>
</li>
<li>
<p><strong>Step 7:</strong>  Populate the 4 dimensional Tnode pointer array, keeping DirectChild nodes closer to the end.</p>
</li>
<li>
<p><strong>Step 8:</strong>  Use the stable Merge-Sort algorithm to sort [MaxChildDepth][LetterIndex] groups by CrcDigest values.</p>
</li>
<li>
<p><strong>Step 9:</strong>  Tag entire Tnode branch structures as Dangling - Elimination begins with DirectChild Tnodes and filters down:</p>
<div class="ulist">
<ul>
<li>
<p>The very heart of DAWG genesis, where the Blitzkrieg shines with CRC, and Tnode Grouping.</p>
</li>
<li>
<p>Seperate groups exist for each [MaxChildDepth]-[LetterIndex] pair.</p>
</li>
<li>
<p>Groups of similar Tnodes, are now sorted by 3 values, [BreadthFirst], [DirectChild], [CrcDigest].</p>
</li>
<li>
<p>This Blitzkrieg Scheme means that each redundant Tnode patch will directly follow its living Tnode replacement.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Step 10:</strong>  Count the number of living Tnodes by traversing the Raw-Trie to check the Dangling numbers.</p>
</li>
<li>
<p><strong>Step 11:</strong>  Using the BlitzkriegTrieAttack, substitute Dangling Tnodes with internal ReplaceMeWith values.</p>
</li>
<li>
<p><strong>Step 12:</strong>  Blitzkrieg Attack is victorious, so assign array indicies to all living Tnodes using a Breadth-First-Queue.</p>
</li>
<li>
<p><strong>Step 13:</strong>  Populate the new Working-Array-Dawg structure, used to verify validity and create the final integer-graph-encodings.
Then verify that all 3 Tnode counting methods yield the same count.</p>
</li>
<li>
<p><strong>Step 14:</strong>  Creation of the traditional-DAWG is complete, so store it in a binary file for use.</p>
</li>
<li>
<p><strong>Step 15:</strong>  Output a text file with all the node information explicitly layed out.</p>
</li>
<li>
<p><strong>Step 16:</strong>  Display the Mask-Format for the DAWG int-nodes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implement"><a class="anchor" href="#implement"></a>C &amp; Java Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Due to popular demand, there are Four versions of DAWG C-code published on this page.
The oldest, more-basic code, the newest Blitzkrieg code, and two intermediate steps.
Download the untampered with files below.
The code being displayed is the dazzling Blitzkrieg Genesis code and a WildCard anagrammer.
The C-code compiles just fine with &#8220;gcc -O3&#8221;, so it works in Linux, and Windows using Cygwin.
If you have an &#8220;Apple&#8221;, I suggest that you decide to buy a real computer next time.
For those who can tolerate Java, source code for the old web-start-app is also available:</p>
</div>
<h3 id="latest_blitzkrieg_c_code" class="discrete">Latest Blitzkrieg C-code</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="./src-c-latest/Word-List.txt" title="View TWL06 word list file" target="_blank" rel="noopener"><code>Word-List.txt</code></a>
&#8201;&#8212;&#8201;TWL06 word list in a correct Windows format.</p>
</li>
<li>
<p><a href="./src-c-latest/Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c" title="View C source file" target="_blank" rel="noopener"><code>Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c</code></a>
&#8201;&#8212;&#8201;Blitzkrieg DAWG Genesis C-code.</p>
</li>
<li>
<p><a href="./src-c-latest/CRC-32.dat" title="View CRC-32 data source file" target="_blank" rel="noopener"><code>CRC-32.dat</code></a>
&#8201;&#8212;&#8201;Byte-wise CRC-32 data file.</p>
</li>
<li>
<p><a href="./src-c-latest/Blitzkrieg_Functionality_Test.c" title="View C source file" target="_blank" rel="noopener"><code>Blitzkrieg_Functionality_Test.c</code></a>
&#8201;&#8212;&#8201;Test the new Blitzkrieg DAWG.</p>
</li>
<li>
<p><a href="./src-c-latest/Compile-CRC-32-Lookup-Table.c" title="View C source file" target="_blank" rel="noopener"><code>Compile-CRC-32-Lookup-Table.c</code></a>
&#8201;&#8212;&#8201;Code used to generate a CRC lookup table.</p>
</li>
</ol>
</div>
<h3 id="old_c_code" class="discrete">Old C-code</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="./src-c-old/Word-List.txt" title="View TWL06 word list file" target="_blank" rel="noopener"><code>Word-List.txt</code></a>
&#8201;&#8212;&#8201;TWL06 word list in a correct Windows format.</p>
</li>
<li>
<p><a href="./src-c-old/TraditionalDawgCreatorUpdate.c" title="View C source file" target="_blank" rel="noopener"><code>TraditionalDawgCreatorUpdate.c</code></a>
&#8201;&#8212;&#8201;The old Traditional-DAWG Creator C-code.</p>
</li>
<li>
<p><a href="./src-c-old/TraditionalDawgCreator.c" title="View C source file" target="_blank" rel="noopener"><code>TraditionalDawgCreator.c</code></a>
&#8201;&#8212;&#8201;The older Traditional-DAWG Creator C-code.</p>
</li>
<li>
<p><a href="./src-c-old/TraditionalDawgAnagrammer.c" title="View C source file" target="_blank" rel="noopener"><code>TraditionalDawgAnagrammer.c</code></a>
&#8201;&#8212;&#8201;DAWG functionality demonstrator C-code.</p>
</li>
</ol>
</div>
<h3 id="older_c_code" class="discrete">Older C-code</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="./src-c-older/Lexicon.txt" title="View TWL06 word list file" target="_blank" rel="noopener"><code>Lexicon.txt</code></a>
&#8201;&#8212;&#8201;TWL06 Scrabble word list in proper text file format</p>
</li>
<li>
<p><a href="./src-c-older/GoogleDawgCreatorSubmit.c" title="View C source file" target="_blank" rel="noopener"><code>GoogleDawgCreatorSubmit.c</code></a>
&#8201;&#8212;&#8201;The even older DAWG-creation C code.</p>
</li>
<li>
<p><a href="./src-c-older/GoogleDawgAnagrammerSubmit.c" title="View C source file" target="_blank" rel="noopener"><code>GoogleDawgAnagrammerSubmit.c</code></a>
&#8201;&#8212;&#8201;The DAWG-testing anagram C code.</p>
</li>
</ol>
</div>
<h3 id="old_java_web_start_code" class="discrete">Old Java Web-Start code</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="./src-java-old/Dawg.java" title="View Java source file" target="_blank" rel="noopener"><code>Dawg.java</code></a>
&#8201;&#8212;&#8201;DAWG functionality code, slanted for use in Java.</p>
</li>
<li>
<p><a href="./src-java-old/Driver.java" title="View Java source file" target="_blank" rel="noopener"><code>Driver.java</code></a>
&#8201;&#8212;&#8201;GUI container, a product of NetBeans.</p>
</li>
<li>
<p><a href="./src-java-old/Traditional_Dawg_For_Word-List.dat" title="Open/Downlaod pre-compiled DAWG data file" target="_blank" rel="noopener"><code>Traditional_Dawg_For_Word-List.dat</code></a>
&#8201;&#8212;&#8201;TWL06 pre-compiled DAWG data file.</p>
</li>
<li>
<p><a href="./src-java-old/Engine.jar" title="Open/Downlaod Jar file" target="_blank" rel="noopener"><code>Engine.jar</code></a>
&#8201;&#8212;&#8201;A runnable Jar file via the Eclipse IDE.</p>
</li>
<li>
<p><a href="./src-java-old/Engine.jnlp" title="View JNLP source file" target="_blank" rel="noopener"><code>Engine.jnlp</code></a>
&#8201;&#8212;&#8201;Java-Web-Start launching protocol file.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="commented-code"><a class="anchor" href="#commented-code"></a>Commented C-code</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="blitzkrieg_dawg_creator"><a class="anchor" href="#blitzkrieg_dawg_creator"></a>Blitzkrieg DAWG Creator</h3>
<div class="listingblock small">
<div class="title"><a href="./src-c-latest/Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c" title="View source file" target="_blank" rel="noopener">&#8220;Blitzkrieg_Trie_Attack_Dawg_Creator_Custom_Character_Set.c&#8221;</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// This program will compile a Traditional DAWG encoding from the "Word-List.txt" file.</span>
<span class="c1">// Updated on Monday, December 29, 2011.</span>

<span class="c1">// A graph compression algorithm this FAST is perfectly suited for record-keeping-compression while solving an NP-Complete.</span>

<span class="c1">// 7 Major concerns addressed:</span>
<span class="c1">// 0) A user defined character set of up to 256 letters is now supported.  This accomodates certain foreign lexicons.</span>
<span class="c1">// 1) Allowance for medium sized word lists. 2^22 DAWG node count is the new upper limit.</span>
<span class="c1">// 2) Superior "ReplaceMeWith" scheme.</span>
<span class="c1">// 3) The use of CRC-Digest calculation, "Tnode" segmentation, and stable group sorting render DAWG creation INSTANTANEOUS.</span>
<span class="c1">// 4) Certain Graph configurataions led the previous version of this program to crash...  NO MORE.</span>
<span class="c1">// 5) A new DAWG int-node format is used to reduce the number of bitwise operations + add direct "char" extraction.</span>

<span class="c1">// "Word-List.txt" is a text file with the number of words written on the very first line, and 1 word per line after that.</span>
<span class="c1">// The words are case-insensitive for English letters, and the text file may have Windows or Linux format.</span>
<span class="c1">// *** MAX is the length of the longest word in the list. Change this value.</span>
<span class="c1">// *** MIN is the length of the shortest word in the list.  Change this value.</span>

<span class="c1">// Include the big-three header files.</span>
<span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="c1">// General high-level program constants.</span>
<span class="cp">#define MERGE_SORT_THRESHOLD 1
#define MIN 2
#define MAX 15
#define SIZE_OF_CHARACTER_SET 26
#define INPUT_LIMIT 35
#define LOWER_IT 32
#define TEN 10
#define INT_BITS 32
#define CHILD_BIT_SHIFT 10
</span><span class="c1">// CHILD_INDEX_BIT_MASK is designed NEVER to be used.</span>
<span class="cp">#define CHILD_INDEX_BIT_MASK 0XFFFFFC00
#define END_OF_WORD_BIT_MASK 0X00000200
#define END_OF_LIST_BIT_MASK 0X00000100
#define LETTER_BIT_MASK 0X000000FF
#define CHILD_CYPHER 0X1EDC6F41
#define NEXT_CYPHER 0X741B8CD7
#define TWO_UP_EIGHT 256
#define LEFT_BYTE_SHIFT 24
#define BYTE_WIDTH 8
</span>
<span class="c1">// C requires a boolean variable type so use C's typedef concept to create one.</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">FALSE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TRUE</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span> <span class="n">Bool</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Bool</span><span class="o">*</span> <span class="n">BoolPtr</span><span class="p">;</span>

<span class="c1">// The lexicon text file.</span>
<span class="cp">#define RAW_LEXICON "Word-List.txt"
</span>
<span class="c1">// This program will create "1" binary-data file for use, and "1" text-data file for inspection.</span>
<span class="cp">#define TRADITIONAL_DAWG_DATA "Traditional_Dawg_For_Word-List.dat"
#define TRADITIONAL_DAWG_TEXT_DATA "Traditional_Dawg_Explicit_Text_For_Word-List.txt"
</span>
<span class="c1">// An explicit table-lookup CRC calculation will be used to identify unique graph branch configurations.</span>
<span class="cp">#define LOOKUP_TABLE_DATA "CRC-32.dat"
</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">TheLookupTable</span><span class="p">[</span><span class="n">TWO_UP_EIGHT</span><span class="p">];</span>

<span class="c1">// Lookup tables used for node encoding and number-string decoding.</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">PowersOfTwo</span><span class="p">[</span><span class="n">INT_BITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0X1</span><span class="p">,</span> <span class="mh">0X2</span><span class="p">,</span> <span class="mh">0X4</span><span class="p">,</span> <span class="mh">0X8</span><span class="p">,</span> <span class="mh">0X10</span><span class="p">,</span> <span class="mh">0X20</span><span class="p">,</span> <span class="mh">0X40</span><span class="p">,</span> <span class="mh">0X80</span><span class="p">,</span> <span class="mh">0X100</span><span class="p">,</span> <span class="mh">0X200</span><span class="p">,</span> <span class="mh">0X400</span><span class="p">,</span> <span class="mh">0X800</span><span class="p">,</span>
 <span class="mh">0X1000</span><span class="p">,</span> <span class="mh">0X2000</span><span class="p">,</span> <span class="mh">0X4000</span><span class="p">,</span> <span class="mh">0X8000</span><span class="p">,</span> <span class="mh">0X10000</span><span class="p">,</span> <span class="mh">0X20000</span><span class="p">,</span> <span class="mh">0X40000</span><span class="p">,</span> <span class="mh">0X80000</span><span class="p">,</span> <span class="mh">0X100000</span><span class="p">,</span> <span class="mh">0X200000</span><span class="p">,</span> <span class="mh">0X400000</span><span class="p">,</span> <span class="mh">0X800000</span><span class="p">,</span> <span class="mh">0X1000000</span><span class="p">,</span>
 <span class="mh">0X2000000</span><span class="p">,</span> <span class="mh">0X4000000</span><span class="p">,</span> <span class="mh">0X8000000</span><span class="p">,</span> <span class="mh">0X10000000</span><span class="p">,</span> <span class="mh">0X20000000</span><span class="p">,</span> <span class="mh">0X40000000</span><span class="p">,</span> <span class="mh">0X80000000</span> <span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">PowersOfTen</span><span class="p">[</span><span class="n">TEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">,</span> <span class="mi">100000000</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="p">};</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">,</span> <span class="sc">'D'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'F'</span><span class="p">,</span> <span class="sc">'G'</span><span class="p">,</span> <span class="sc">'H'</span><span class="p">,</span> <span class="sc">'I'</span><span class="p">,</span> <span class="sc">'J'</span><span class="p">,</span> <span class="sc">'K'</span><span class="p">,</span>
 <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'M'</span><span class="p">,</span> <span class="sc">'N'</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'P'</span><span class="p">,</span> <span class="sc">'Q'</span><span class="p">,</span> <span class="sc">'R'</span><span class="p">,</span> <span class="sc">'S'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">,</span> <span class="sc">'U'</span><span class="p">,</span> <span class="sc">'V'</span><span class="p">,</span> <span class="sc">'W'</span><span class="p">,</span> <span class="sc">'X'</span><span class="p">,</span> <span class="sc">'Y'</span><span class="p">,</span> <span class="sc">'Z'</span> <span class="p">};</span>

 <span class="c1">// Some word lists will contain letters that NO words begin with.  Place "0"s in the corresponding positions.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EntryNodeIndex</span><span class="p">[</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span>
 <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span> <span class="p">};</span>

<span class="c1">// This simple function clips off the extra chars for each "fgets()" line.  Works for Linux and Windows text format.</span>
<span class="kt">void</span> <span class="nf">CutOffExtraChars</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ThisLine</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisLine</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\r'</span> <span class="p">)</span> <span class="n">ThisLine</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">ThisLine</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\n'</span> <span class="p">)</span> <span class="n">ThisLine</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns "FALSE" if "TheWord" contains any character not defined in "CharacterSet", and "TRUE" otherwise.</span>
<span class="n">Bool</span> <span class="nf">TestForValidWord</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">TheWord</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">TheWord</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">TheWord</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">NestedContinue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="nl">NestedContinue:</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Return the index position of character "ThisChar", as it appears in "CharacterSet", and it must exist in the set.</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">CharToIndexConversion</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ThisChar</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisChar</span> <span class="o">==</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span> <span class="p">)</span> <span class="k">return</span> <span class="n">Y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// "TheWord" must consist of valid letters within "CharacterSet".</span>
<span class="c1">// This function converts "TheWord" from actual characters into index values and stores them into "TheWordByIndex".</span>
<span class="kt">void</span> <span class="nf">LettersToIndexConversion</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">TheWord</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">TheWordByIndex</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">TheWord</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TheWordByIndex</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">CharToIndexConversion</span><span class="p">(</span><span class="n">TheWord</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Returns the positive "int" rerpresented by "TheNumberNotYet" string.  An invalid "TheNumberNotYet" returns "0".</span>
<span class="kt">int</span> <span class="nf">StringToPositiveInt</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">TheNumberNotYet</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">TheNumberNotYet</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Length</span> <span class="o">&gt;</span> <span class="n">TEN</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">TheNumberNotYet</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="n">TheNumberNotYet</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">'9'</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">Result</span> <span class="o">+=</span> <span class="p">((</span><span class="n">TheNumberNotYet</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">)</span><span class="o">*</span><span class="n">PowersOfTen</span><span class="p">[</span><span class="n">Length</span> <span class="o">-</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// The "BinaryNode" string must be at least 32 + 5 + 1 bytes in length.  Space for the bits,</span>
<span class="c1">// the seperation pipes, and the end of string char.</span>
<span class="c1">// This function is used to fill the text file used to inspect the graph created in the first segment of the program.</span>
<span class="kt">void</span> <span class="nf">ConvertIntNodeToBinaryString</span><span class="p">(</span><span class="kt">int</span> <span class="n">TheNode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">BinaryNode</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Bit</span><span class="p">;</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'['</span><span class="p">;</span>
    <span class="c1">// 22 Bits, (31--&gt;10) hold the First-Child index.</span>
    <span class="n">Bit</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">22</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span><span class="p">,</span> <span class="n">Bit</span><span class="o">--</span> <span class="p">)</span> <span class="n">BinaryNode</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TheNode</span> <span class="o">&amp;</span> <span class="n">PowersOfTwo</span><span class="p">[</span><span class="n">Bit</span><span class="p">])</span><span class="o">?</span><span class="sc">'1'</span><span class="o">:</span><span class="sc">'0'</span><span class="p">;</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'|'</span><span class="p">;</span>
    <span class="c1">// Bit 9 holds the End-Of-Word flag.</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TheNode</span> <span class="o">&amp;</span> <span class="n">END_OF_WORD_BIT_MASK</span><span class="p">)</span><span class="o">?</span><span class="sc">'1'</span><span class="o">:</span><span class="sc">'0'</span><span class="p">;</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'|'</span><span class="p">;</span>
    <span class="c1">// Bit 8 holds the End-Of-List flag.</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TheNode</span> <span class="o">&amp;</span> <span class="n">END_OF_LIST_BIT_MASK</span><span class="p">)</span><span class="o">?</span><span class="sc">'1'</span><span class="o">:</span><span class="sc">'0'</span><span class="p">;</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'|'</span><span class="p">;</span>
    <span class="c1">// The Letter is held in the final 8 bits, (7-&gt;0).</span>
    <span class="n">Bit</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">35</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span><span class="p">,</span> <span class="n">Bit</span><span class="o">--</span> <span class="p">)</span> <span class="n">BinaryNode</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TheNode</span> <span class="o">&amp;</span> <span class="n">PowersOfTwo</span><span class="p">[</span><span class="n">Bit</span><span class="p">])</span><span class="o">?</span><span class="sc">'1'</span><span class="o">:</span><span class="sc">'0'</span><span class="p">;</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="sc">']'</span><span class="p">;</span>
    <span class="n">BinaryNode</span><span class="p">[</span><span class="mi">37</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//This Function converts any lower case letters inside "RawWord" to capitals, so that the whole string is made of capital letters.</span>
<span class="kt">void</span> <span class="nf">MakeMeAllCapital</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">RawWord</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">RawWord</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Count</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">;</span> <span class="n">Count</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">Count</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">Count</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'z'</span> <span class="p">)</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">Count</span><span class="p">]</span> <span class="o">-=</span> <span class="n">LOWER_IT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function performs a Byte-wise lookup table CRC calculation on "NumberOfBytes" Bytes, starting at "DataMessage".</span>
<span class="c1">// The Polynomial used to generate the lookup table is CRC-32 = 0X04C11DB7.</span>
<span class="c1">// The value returned by the function is the "CRC-Digest".</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">LookupTableCrc</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">DataMessage</span><span class="p">,</span> <span class="kt">int</span> <span class="n">NumberOfBytes</span><span class="p">,</span> <span class="n">Bool</span> <span class="n">Print</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Print</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"|"</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">NumberOfBytes</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%02X"</span><span class="p">,</span> <span class="n">DataMessage</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">X</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"|"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">" - Length |%d|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfBytes</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Because looking up "0" in the table returns "0", it is safe to use a table lookup to fill the "WorkingRegister" with its initial "DataMessage" value.</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WorkingRegister</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Query the "LookupTable" exactly "NumberOfBytes" times.  Perform lookups using the value inside of "WorkingRegister" as the index.</span>
    <span class="c1">// After each table query, "XOR" the value returned by "TheLookupTable" with "WorkingRegister" after pulling in the next Byte of "DataMessage".</span>
    <span class="c1">// "X" is the location of the next data Byte to pull into the calculation.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">NumberOfBytes</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">WorkingRegister</span> <span class="o">=</span> <span class="n">TheLookupTable</span><span class="p">[</span><span class="n">WorkingRegister</span> <span class="o">&gt;&gt;</span> <span class="n">LEFT_BYTE_SHIFT</span><span class="p">]</span> <span class="o">^</span> <span class="p">((</span><span class="n">WorkingRegister</span> <span class="o">&lt;&lt;</span> <span class="n">BYTE_WIDTH</span><span class="p">)</span> <span class="o">^</span> <span class="n">DataMessage</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Print</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Calculated Digest = |%08X|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WorkingRegister</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">WorkingRegister</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Trie to Dawg TypeDefs*/</span>
<span class="k">struct</span> <span class="n">tnode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">tnode</span><span class="o">*</span> <span class="n">Next</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">tnode</span><span class="o">*</span> <span class="n">Child</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">tnode</span><span class="o">*</span> <span class="n">ParentalUnit</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">tnode</span><span class="o">*</span> <span class="n">ReplaceMeWith</span><span class="p">;</span>
    <span class="c1">// When populating the DAWG array, you must know the index assigned to each "Child".</span>
    <span class="c1">// "ArrayIndex" Is stored in every node, so that we can mine the information from the Trie.</span>
    <span class="kt">int</span> <span class="n">ArrayIndex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">InternalValues</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">DirectChild</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">LetterIndex</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">MaxChildDepth</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">Level</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">NumberOfChildren</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">DistanceToEndOfList</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">Dangling</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">Protected</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">EndOfWordFlag</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CrcDigest</span><span class="p">;</span>
    <span class="c1">// To streamline checking if "Protected" "Tnode"s are up for "Dangling", filter "ProtectedUnderCount" up to the root "Tnode"; do it on the fly.</span>
    <span class="kt">int</span> <span class="n">ProtectedUnderCount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="n">Tnode</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Tnode</span><span class="o">*</span> <span class="n">TnodePtr</span><span class="p">;</span>

<span class="c1">// Functions to access internal "Tnode" members.</span>
<span class="kt">int</span> <span class="nf">TnodeArrayIndex</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">ArrayIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">TnodeDirectChild</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DirectChild</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TnodePtr</span> <span class="nf">TnodeNext</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TnodePtr</span> <span class="nf">TnodeChild</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TnodePtr</span> <span class="nf">TnodeParentalUnit</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TnodePtr</span> <span class="nf">TnodeReplaceMeWith</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">ReplaceMeWith</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">TnodeLetterIndex</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">TnodeMaxChildDepth</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">MaxChildDepth</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">TnodeNumberOfChildren</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">TnodeDistanceToEndOfList</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">TnodeEndOfWordFlag</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">TnodeLevel</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">TnodeDangling</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Dangling</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">TnodeProtected</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Protected</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">TnodeCrcDigest</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Allocate a "Tnode" and fill it with initial values.</span>
<span class="n">TnodePtr</span> <span class="nf">TnodeInit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ChapIndex</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">OverOne</span><span class="p">,</span> <span class="kt">char</span> <span class="n">WordEnding</span><span class="p">,</span> <span class="kt">char</span> <span class="n">Leveler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">StarterDepth</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Parent</span><span class="p">,</span> <span class="kt">char</span> <span class="n">IsaChild</span><span class="p">,</span> <span class="kt">char</span> <span class="n">StartListPosition</span><span class="p">){</span>
    <span class="n">TnodePtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Tnode</span><span class="p">));</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">=</span> <span class="n">ChapIndex</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">ArrayIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">InternalValues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span> <span class="o">=</span> <span class="n">StartListPosition</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">MaxChildDepth</span> <span class="o">=</span> <span class="n">StarterDepth</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">OverOne</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Protected</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">ReplaceMeWith</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span> <span class="o">=</span> <span class="n">WordEnding</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="n">Leveler</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DirectChild</span> <span class="o">=</span> <span class="n">IsaChild</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">CrcDigest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Use this for debugging any program modifications.</span>
<span class="kt">void</span> <span class="nf">TnodeOutput</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"|%c|%d|%d|%d|%X|-|%X|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span><span class="p">],</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span><span class="p">,</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span><span class="p">,</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span><span class="p">,</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">,</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeOutput</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Modify internal "Tnode" member values.</span>
<span class="kt">void</span> <span class="nf">TnodeSetArrayIndex</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">TheWhat</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">ArrayIndex</span> <span class="o">=</span> <span class="n">TheWhat</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeSetChild</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Chump</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">Chump</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeSetNext</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Nexis</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">Nexis</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeSetParentalUnit</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Parent</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeSetReplaceMeWith</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Living</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">ReplaceMeWith</span> <span class="o">=</span> <span class="n">Living</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeSetMaxChildDepth</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">NewDepth</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">MaxChildDepth</span> <span class="o">=</span> <span class="n">NewDepth</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeSetDirectChild</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="kt">char</span> <span class="n">Status</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DirectChild</span> <span class="o">=</span> <span class="n">Status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TnodeFlyEndOfWordFlag</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This statement evaluates to TRUE when the CRC at "one" has a higher value than the CRC at "two".  "one" and "two" are indicies of "arrayone", and "arraytwo".</span>
<span class="cp">#define COMPARE_TNODES(arrayone, one, arraytwo, two) ( arrayone[one]-&gt;CrcDigest &gt; arraytwo[two]-&gt;CrcDigest )
</span>
<span class="kt">void</span> <span class="nf">TnodeArrayMergeSortRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="o">*</span><span class="n">OriginalArray</span><span class="p">,</span> <span class="kt">int</span> <span class="n">TheSize</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="o">*</span><span class="n">ExtraArray</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">FirstSize</span> <span class="o">=</span> <span class="n">TheSize</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">SecondSize</span> <span class="o">=</span> <span class="n">TheSize</span> <span class="o">-</span> <span class="n">FirstSize</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">FirstIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">SecondIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">InsertIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="o">*</span><span class="n">TheFirst</span> <span class="o">=</span> <span class="n">OriginalArray</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="o">*</span><span class="n">TheSecond</span> <span class="o">=</span> <span class="n">OriginalArray</span> <span class="o">+</span> <span class="n">FirstSize</span><span class="p">;</span>
    <span class="c1">// Testing the escape condition before calling "TnodeArrayMergeSort" reduces stack overhead.</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">FirstSize</span> <span class="o">&gt;</span> <span class="n">MERGE_SORT_THRESHOLD</span> <span class="p">)</span> <span class="n">TnodeArrayMergeSortRecurse</span><span class="p">(</span><span class="n">TheFirst</span><span class="p">,</span> <span class="n">FirstSize</span><span class="p">,</span> <span class="n">ExtraArray</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">SecondSize</span> <span class="o">&gt;</span> <span class="n">MERGE_SORT_THRESHOLD</span> <span class="p">)</span> <span class="n">TnodeArrayMergeSortRecurse</span><span class="p">(</span><span class="n">TheSecond</span><span class="p">,</span> <span class="n">SecondSize</span><span class="p">,</span> <span class="n">ExtraArray</span><span class="p">);</span>
    <span class="c1">// We can now conclude that the two lists are sorted, so merge them into the "ExtraArray".</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">FirstIndex</span> <span class="o">&lt;</span> <span class="n">FirstSize</span> <span class="o">&amp;&amp;</span> <span class="n">SecondIndex</span> <span class="o">&lt;</span> <span class="n">SecondSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Using this comparison macro ensures that the sort will be stable.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">COMPARE_TNODES</span><span class="p">(</span><span class="n">TheSecond</span><span class="p">,</span> <span class="n">SecondIndex</span><span class="p">,</span> <span class="n">TheFirst</span><span class="p">,</span> <span class="n">FirstIndex</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ExtraArray</span><span class="p">[</span><span class="n">InsertIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">TheSecond</span><span class="p">[</span><span class="n">SecondIndex</span><span class="p">];</span>
            <span class="n">SecondIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">InsertIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">ExtraArray</span><span class="p">[</span><span class="n">InsertIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">TheFirst</span><span class="p">[</span><span class="n">FirstIndex</span><span class="p">];</span>
            <span class="n">FirstIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">InsertIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// This instruction copies the remaining elements from the unfinished list into the "ExtraArray".</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">FirstIndex</span> <span class="o">==</span> <span class="n">FirstSize</span><span class="p">)</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">ExtraArray</span> <span class="o">+</span> <span class="n">InsertIndex</span><span class="p">,</span> <span class="n">TheSecond</span> <span class="o">+</span> <span class="n">SecondIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">SecondSize</span> <span class="o">-</span> <span class="n">SecondIndex</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span><span class="p">));</span>
    <span class="k">else</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">ExtraArray</span> <span class="o">+</span> <span class="n">InsertIndex</span><span class="p">,</span> <span class="n">TheFirst</span> <span class="o">+</span> <span class="n">FirstIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">FirstSize</span> <span class="o">-</span> <span class="n">FirstIndex</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">OriginalArray</span><span class="p">,</span> <span class="n">ExtraArray</span><span class="p">,</span> <span class="n">TheSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// After all words have been added to the initial Trie, this function will combine the internal comparison values of "ThisTnode" into its "InternalValues".</span>
<span class="kt">void</span> <span class="nf">TnodeCalculateInternalValues</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">TheBytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">);</span>
    <span class="n">TheBytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span><span class="p">;</span>
    <span class="n">TheBytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span><span class="p">;</span>
    <span class="n">TheBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span><span class="p">;</span>
    <span class="n">TheBytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">MaxChildDepth</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Recursively calculate all "InternalValues" within a "Tnode" graph.  "ThisTnode" must not be NULL.</span>
<span class="kt">void</span> <span class="nf">TnodeCalculateInternalValuesRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="n">TnodeCalculateInternalValues</span><span class="p">(</span><span class="n">ThisTnode</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeCalculateInternalValuesRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeCalculateInternalValuesRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The "CrcDigest" of a "Tnode" is heavily based on its "InternalValues".</span>
<span class="c1">// Further, when a "Tnode" has a "Child" list OR it is NOT at the end of a list,</span>
<span class="c1">// a data message is created using a series of "Child" and "NEXT" "CrcDigest"s.</span>
<span class="c1">// These packets of data are seperated by "CYPHER" "int"s to distinguish "Tnode" branch structures.</span>
<span class="c1">// Finally, a Byte-Wise Crc-Lookup-Table is used to convert the resulting data-message into a 32 bit "CrcDigest".</span>
<span class="kt">void</span> <span class="nf">TnodeCalculateCrcDigest</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="n">Bool</span> <span class="n">Print</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">TheMessage</span><span class="p">[(</span><span class="n">SIZE_OF_CHARACTER_SET</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">MessageLength</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">FillSpace</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">Current</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// "ThisTnode" is a terminal node, so just use its "InternalValues" as its "CrcDigest".</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// "ThisTnode" has a "Child" list, but is located at the end of its own "Tnode" list.</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">TheMessage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
            <span class="n">TheMessage</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CHILD_CYPHER</span><span class="p">;</span>
            <span class="n">MessageLength</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">FillSpace</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">FillSpace</span> <span class="o">&lt;</span> <span class="n">MessageLength</span><span class="p">;</span> <span class="n">FillSpace</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"ZERO in CRC of Child.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">TheMessage</span><span class="p">[</span><span class="n">MessageLength</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
            <span class="n">MessageLength</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span> <span class="n">Print</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">MessageLength</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"|%08X"</span><span class="p">,</span> <span class="n">TheMessage</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"|</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span> <span class="o">=</span> <span class="n">LookupTableCrc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">TheMessage</span><span class="p">,</span> <span class="n">MessageLength</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Print</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">Print</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Inherited  Digest = |%X| - Length|%d|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">,</span> <span class="n">MessageLength</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// "ThisTnode" has no "Child" list, but has following "Tnode"s in its own list.</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TheMessage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
        <span class="n">TheMessage</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NEXT_CYPHER</span><span class="p">;</span>
        <span class="n">MessageLength</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">FillSpace</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">FillSpace</span> <span class="o">&lt;</span> <span class="n">MessageLength</span><span class="p">;</span> <span class="n">FillSpace</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"ZERO in CRC of Next.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">TheMessage</span><span class="p">[</span><span class="n">MessageLength</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
        <span class="n">MessageLength</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span> <span class="o">=</span> <span class="n">LookupTableCrc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">TheMessage</span><span class="p">,</span> <span class="n">MessageLength</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Print</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// "ThisTnode" has a "Child" list, and also has following "Tnode"s in its own list.</span>
    <span class="n">TheMessage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
    <span class="n">TheMessage</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CHILD_CYPHER</span><span class="p">;</span>
    <span class="n">MessageLength</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">Current</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">FillSpace</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">FillSpace</span> <span class="o">&lt;</span> <span class="n">MessageLength</span><span class="p">;</span> <span class="n">FillSpace</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"ZERO in CRC of BChild.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">TheMessage</span><span class="p">[</span><span class="n">MessageLength</span><span class="p">]</span> <span class="o">=</span> <span class="n">NEXT_CYPHER</span><span class="p">;</span>
    <span class="n">MessageLength</span> <span class="o">+=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">Current</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">FillSpace</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">FillSpace</span> <span class="o">&lt;</span> <span class="n">MessageLength</span><span class="p">;</span> <span class="n">FillSpace</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">TheMessage</span><span class="p">[</span><span class="n">FillSpace</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"ZERO in CRC of BNext.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TheMessage</span><span class="p">[</span><span class="n">MessageLength</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">InternalValues</span><span class="p">;</span>
    <span class="n">MessageLength</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span> <span class="o">=</span> <span class="n">LookupTableCrc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">TheMessage</span><span class="p">,</span> <span class="n">MessageLength</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Print</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// When calculating the "CrcDigest" of a "Tnode", its "Next" list and "Child" list must already have calculated "CrcDigest"s.</span>
<span class="kt">void</span> <span class="nf">TnodeCalculateCrcDigestRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeCalculateCrcDigestRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeCalculateCrcDigestRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
    <span class="n">TnodeCalculateCrcDigest</span><span class="p">(</span><span class="n">ThisTnode</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This function Dangles a "Tnode", but also recursively dangles every "Tnode" after and below it as well.</span>
<span class="c1">// Dangling a "Tnode" means that it will be exculded from the final "DAWG" encoding.</span>
<span class="c1">// By recursion, nodes that are not direct children will get dangled.</span>
<span class="c1">// The function returns the total number of nodes dangled as a result.</span>
<span class="kt">int</span> <span class="nf">TnodeDangleRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Protected</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  There is NO scenario where Dangling a Protected node should happen.  ERROR, ERROR, ERROR.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">Result</span> <span class="o">+=</span> <span class="n">TnodeDangleRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">Result</span> <span class="o">+=</span> <span class="n">TnodeDangleRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="p">)</span><span class="n">Result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This function "Protects" a node being directly referenced in the elimination process.</span>
<span class="c1">// "Protected" "Tnode"s should NEVER be "Dangling".</span>
<span class="c1">// Make sure to increment "ProtectedUnderCount" by "1" all the way up to the root "Tnode".</span>
<span class="kt">void</span> <span class="nf">TnodeProtect</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="n">TnodePtr</span> <span class="n">Current</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Protected</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Protected</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Current</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function returns the pointer to the "Tnode" in a parallel list of "Tnodes" with the "LetterIndex" "ThisLetterIndex",</span>
<span class="c1">// and returns "NULL" if the "Tnode" does not exist.</span>
<span class="c1">// If the function returns "NULL", then an insertion is required.</span>
<span class="n">TnodePtr</span> <span class="nf">TnodeFindParaNode</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ThisLetterIndex</span><span class="p">){</span>
    <span class="n">TnodePtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">==</span> <span class="n">ThisLetterIndex</span> <span class="p">)</span> <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">&lt;</span> <span class="n">ThisLetterIndex</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">Result</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">==</span> <span class="n">ThisLetterIndex</span> <span class="p">)</span> <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This function inserts a new "Tnode" before a larger "LetterIndex" "Tnode" or at the end of a para list.</span>
<span class="c1">// If the list does not exist, then it is put at the beginnung.</span>
<span class="c1">// The new "Tnode" has "ThisLetterIndex" in it.  "AboveTnode" is the "Tnode" 1 level above where the new node will be placed.</span>
<span class="c1">// This function should never be passed a "NULL" pointer.  "ThisLetterIndex" should never exist in the "Child" "Tnode" list.</span>
<span class="kt">void</span> <span class="nf">TnodeInsertParaNode</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">AboveTnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ThisLetterIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="n">WordEnder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">StartDepth</span><span class="p">){</span>
    <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">Holder</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">Currently</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// Case 1: ParaList does not exist yet so start it.</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">TnodeInit</span><span class="p">(</span><span class="n">ThisLetterIndex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WordEnder</span><span class="p">,</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">StartDepth</span><span class="p">,</span> <span class="n">AboveTnode</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Case 2: "ThisLetterIndex" should be the first in the ParaList.</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">&gt;</span> <span class="n">ThisLetterIndex</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Holder</span> <span class="o">=</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
        <span class="c1">// The holder node is no longer a direct child so set it as such.</span>
        <span class="n">TnodeSetDirectChild</span><span class="p">(</span><span class="n">Holder</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
        <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">TnodeInit</span><span class="p">(</span><span class="n">ThisLetterIndex</span><span class="p">,</span> <span class="n">Holder</span><span class="p">,</span> <span class="n">WordEnder</span><span class="p">,</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">StartDepth</span><span class="p">,</span> <span class="n">AboveTnode</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TnodeDistanceToEndOfList</span><span class="p">(</span><span class="n">Holder</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// The parent node needs to be changed on what used to be the child. it is the Tnode in "Holder".</span>
        <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Case 3: The ParaList exists and "ThisLetterIndex" is not first in the list.</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">Currently</span> <span class="o">=</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">!=</span><span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">&gt;</span> <span class="n">ThisLetterIndex</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">Currently</span> <span class="o">=</span> <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Holder</span> <span class="o">=</span> <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">TnodeInit</span><span class="p">(</span><span class="n">ThisLetterIndex</span><span class="p">,</span> <span class="n">Holder</span><span class="p">,</span> <span class="n">WordEnder</span><span class="p">,</span> <span class="n">AboveTnode</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">StartDepth</span><span class="p">,</span> <span class="n">Currently</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span><span class="p">);</span>
        <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">Holder</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">Currently</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dawg</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">NumberOfTotalWords</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">NumberOfTotalNodes</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">First</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dawg</span> <span class="n">Dawg</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Dawg</span><span class="o">*</span> <span class="n">DawgPtr</span><span class="p">;</span>

<span class="c1">// Set up the parent nodes in the Dawg.</span>
<span class="n">DawgPtr</span> <span class="nf">DawgInit</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">DawgPtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dawg</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Dawg</span><span class="p">));</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">NumberOfTotalWords</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">NumberOfTotalNodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">First</span> <span class="o">=</span> <span class="n">TnodeInit</span><span class="p">(</span><span class="sc">'0'</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Return the root node of "ThisDawg", which is a direct child of the "First" node.</span>
<span class="n">TnodePtr</span> <span class="nf">DawgRootNode</span><span class="p">(</span><span class="n">DawgPtr</span> <span class="n">ThisDawg</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">TnodeChild</span><span class="p">(</span><span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This function is responsible for adding "WordByIndexes" to the "Dawg" under its root node.</span>
<span class="c1">// It returns the number of new nodes inserted.</span>
<span class="kt">int</span> <span class="nf">TnodeDawgAddWord</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ParentNode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">WordByIndexes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">WordSize</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">HangPoint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">Current</span> <span class="o">=</span> <span class="n">ParentNode</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">WordSize</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span><span class="p">){</span>
        <span class="n">HangPoint</span> <span class="o">=</span> <span class="n">TnodeFindParaNode</span><span class="p">(</span><span class="n">TnodeChild</span><span class="p">(</span><span class="n">Current</span><span class="p">),</span> <span class="n">WordByIndexes</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">HangPoint</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">TnodeInsertParaNode</span><span class="p">(</span><span class="n">Current</span><span class="p">,</span> <span class="n">WordByIndexes</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="p">(</span><span class="n">X</span> <span class="o">==</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">TRUE</span> <span class="o">:</span> <span class="n">FALSE</span><span class="p">),</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">Result</span><span class="o">++</span><span class="p">;</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">TnodeFindParaNode</span><span class="p">(</span><span class="n">TnodeChild</span><span class="p">(</span><span class="n">Current</span><span class="p">),</span> <span class="n">WordByIndexes</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">WordSize</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">TnodeInsertParaNode</span><span class="p">(</span><span class="n">Current</span><span class="p">,</span> <span class="n">WordByIndexes</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="p">(</span><span class="n">Y</span> <span class="o">==</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">TRUE</span> <span class="o">:</span> <span class="n">FALSE</span><span class="p">),</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="n">Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">Result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">Current</span> <span class="o">=</span> <span class="n">TnodeChild</span><span class="p">(</span><span class="n">Current</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">TnodeMaxChildDepth</span><span class="p">(</span><span class="n">HangPoint</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="n">TnodeSetMaxChildDepth</span><span class="p">(</span><span class="n">HangPoint</span><span class="p">,</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">HangPoint</span><span class="p">;</span>
        <span class="c1">// The path for the "WordByIndexes" that we are trying to insert already exists,</span>
        <span class="c1">// so just make sure that the end flag is flying on the last node.</span>
        <span class="c1">// This should never happen if we are to add words in alphabetical order and increasing "WordByIndexes" length.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">X</span> <span class="o">==</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="n">TnodeFlyEndOfWordFlag</span><span class="p">(</span><span class="n">Current</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Add "NewWord" to "ThisDawg", which at this point is a "Trie" with a lot of information in each node.</span>
<span class="c1">// "NewWord" must not exist in "ThisDawg" already.</span>
<span class="kt">void</span> <span class="nf">DawgAddWord</span><span class="p">(</span><span class="n">DawgPtr</span> <span class="n">ThisDawg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">NewWordByIndexes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">WordLength</span><span class="p">){</span>
    <span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">NumberOfTotalWords</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">NumberOfTotalNodes</span> <span class="o">+=</span> <span class="n">TnodeDawgAddWord</span><span class="p">(</span><span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">,</span> <span class="n">NewWordByIndexes</span><span class="p">,</span> <span class="n">WordLength</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This is a standard depth first inorder tree traversal.</span>
<span class="c1">// Count un"Dangling" "Tnodes" into the 780 groups by "MaxChildDepth", "LetterIndex", and "DirectChild", then store values into "Tabulator".</span>
<span class="kt">void</span> <span class="nf">TnodeGraphTabulateRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">,</span> <span class="kt">int</span> <span class="o">***</span><span class="n">Tabulator</span><span class="p">){</span>
    <span class="c1">// We will only ever be concerned with "Living" nodes.  "Dangling" Nodes will be eliminated, so don't count them.</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Tabulator</span><span class="p">[</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">MaxChildDepth</span><span class="p">][</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span><span class="p">][</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DirectChild</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// Go Down if possible.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeGraphTabulateRecurse</span><span class="p">(</span><span class="n">TnodeChild</span><span class="p">(</span><span class="n">ThisTnode</span><span class="p">),</span> <span class="n">Tabulator</span><span class="p">);</span>
        <span class="c1">// Go Right if possible.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeGraphTabulateRecurse</span><span class="p">(</span><span class="n">TnodeNext</span><span class="p">(</span><span class="n">ThisTnode</span><span class="p">),</span> <span class="n">Tabulator</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Count the "Living" "Tnode"s into the 780 groups by "MaxChildDepth", "LetterIndex", and "DirectChild", then store values into "Count".</span>
<span class="kt">void</span> <span class="nf">DawgGraphTabulate</span><span class="p">(</span><span class="n">DawgPtr</span> <span class="n">ThisDawg</span><span class="p">,</span> <span class="kt">int</span> <span class="o">***</span><span class="n">Count</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">NumberOfTotalWords</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TnodeGraphTabulateRecurse</span><span class="p">(</span><span class="n">TnodeChild</span><span class="p">(</span><span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">),</span> <span class="n">Count</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Recursively replaces all redundant "Tnode"s under "ThisTnode", in one penetrating assult.</span>
<span class="c1">// "DirectChild" "Tnode"s in a "Dangling" state have "ReplaceMeWith" set within them.</span>
<span class="kt">void</span> <span class="nf">TnodeBlitzAttackRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// The first "Tnode" being eliminated will always be a "DirectChild".</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// The node is tagged to be excised, so replace it with "ReplaceMeWith".</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="o">-&gt;</span><span class="n">ReplaceMeWith</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">TnodeBlitzAttackRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">){</span>
        <span class="n">TnodeBlitzAttackRecurse</span><span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Replaces all pointers to "Dangling" "Child" "Tnodes" in the "ThisDawg" Trie with living ones.</span>
<span class="kt">void</span> <span class="nf">BlitzkriegTrieAttack</span><span class="p">(</span><span class="n">DawgPtr</span> <span class="n">ThisDawg</span><span class="p">){</span>
    <span class="n">TnodeBlitzAttackRecurse</span><span class="p">(</span><span class="n">ThisDawg</span><span class="o">-&gt;</span><span class="n">First</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// A recursive function which Exchanges a single "Protected" "Tnode" under "ToDangle" with the corresponding "Tnode" under "ToKeep".</span>
<span class="c1">// Remember to update "ProtectedUnderCount" for each line of "Tnodes" after the exchange.</span>
<span class="kt">void</span> <span class="nf">TnodeExchangeProtectedNodeRecurse</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">ToDangle</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">ToKeep</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">ProtectedUnderCountParity</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">Holder</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">Protected</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">DirectChild</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">//printf("Protected ToDangle = DirectChild");</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ReplaceMeWith</span> <span class="o">==</span> <span class="n">ToDangle</span> <span class="p">)</span> <span class="p">{</span>
                <span class="c1">//printf(" - Standard Crosslink");</span>
                <span class="n">ProtectedUnderCountParity</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">-</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span><span class="p">;</span>
                <span class="n">Holder</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">Holder</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">-=</span> <span class="n">ProtectedUnderCountParity</span><span class="p">;</span>
                    <span class="n">Holder</span> <span class="o">=</span> <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">Holder</span> <span class="o">=</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">Holder</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">+=</span> <span class="n">ProtectedUnderCountParity</span><span class="p">;</span>
                    <span class="n">Holder</span> <span class="o">=</span> <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="p">(</span><span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="p">;</span>
                <span class="p">(</span><span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">ToKeep</span><span class="p">;</span>
                <span class="n">Holder</span> <span class="o">=</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">Holder</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// This case is not possible.</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// The "Protected" "Tnode" is not a "DirectChild".</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//printf(" - ToKeep = Dangling - Something is FUCKED up.");</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">//printf(" - ToKeep != Dangling");</span>
                <span class="n">ProtectedUnderCountParity</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">-</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span><span class="p">;</span>
                <span class="n">Holder</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">Holder</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">-=</span> <span class="n">ProtectedUnderCountParity</span><span class="p">;</span>
                    <span class="n">Holder</span> <span class="o">=</span> <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">Holder</span> <span class="o">=</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">Holder</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="o">+=</span> <span class="n">ProtectedUnderCountParity</span><span class="p">;</span>
                    <span class="n">Holder</span> <span class="o">=</span> <span class="n">Holder</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="p">(</span><span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="p">;</span>
                <span class="p">(</span><span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">ToKeep</span><span class="p">;</span>
                <span class="n">Holder</span> <span class="o">=</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span><span class="p">;</span>
                <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">ParentalUnit</span> <span class="o">=</span> <span class="n">Holder</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeExchangeProtectedNodeRecurse</span><span class="p">(</span><span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">,</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">TnodeExchangeProtectedNodeRecurse</span><span class="p">(</span><span class="n">ToDangle</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">,</span> <span class="n">ToKeep</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// A queue is required for breadth first traversal, and the rest is self-evident.</span>

<span class="k">struct</span> <span class="n">breadthqueuenode</span> <span class="p">{</span>
    <span class="n">TnodePtr</span> <span class="n">Element</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">breadthqueuenode</span> <span class="o">*</span><span class="n">Next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">breadthqueuenode</span> <span class="n">BreadthQueueNode</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">BreadthQueueNode</span><span class="o">*</span> <span class="n">BreadthQueueNodePtr</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">BreadthQueueNodeSetNext</span><span class="p">(</span><span class="n">BreadthQueueNodePtr</span> <span class="n">ThisBreadthQueueNode</span><span class="p">,</span> <span class="n">BreadthQueueNodePtr</span> <span class="n">Nexit</span><span class="p">){</span>
        <span class="n">ThisBreadthQueueNode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">Nexit</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BreadthQueueNodePtr</span> <span class="nf">BreadthQueueNodeNext</span><span class="p">(</span><span class="n">BreadthQueueNodePtr</span> <span class="n">ThisBreadthQueueNode</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">ThisBreadthQueueNode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TnodePtr</span> <span class="nf">BreadthQueueNodeElement</span><span class="p">(</span><span class="n">BreadthQueueNodePtr</span> <span class="n">ThisBreadthQueueNode</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">ThisBreadthQueueNode</span><span class="o">-&gt;</span><span class="n">Element</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BreadthQueueNodePtr</span> <span class="nf">BreadthQueueNodeInit</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="n">NewElement</span><span class="p">){</span>
    <span class="n">BreadthQueueNodePtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">BreadthQueueNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BreadthQueueNode</span><span class="p">));</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Element</span> <span class="o">=</span> <span class="n">NewElement</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">breadthqueue</span> <span class="p">{</span>
    <span class="n">BreadthQueueNodePtr</span> <span class="n">Front</span><span class="p">;</span>
    <span class="n">BreadthQueueNodePtr</span> <span class="n">Back</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">breadthqueue</span> <span class="n">BreadthQueue</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">BreadthQueue</span><span class="o">*</span> <span class="n">BreadthQueuePtr</span><span class="p">;</span>

<span class="n">BreadthQueuePtr</span> <span class="nf">BreadthQueueInit</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">BreadthQueuePtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">BreadthQueue</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BreadthQueue</span><span class="p">));</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Back</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">BreadthQueuePush</span><span class="p">(</span><span class="n">BreadthQueuePtr</span> <span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">NewElemental</span><span class="p">){</span>
    <span class="n">BreadthQueueNodePtr</span> <span class="n">Noob</span> <span class="o">=</span> <span class="n">BreadthQueueNodeInit</span><span class="p">(</span><span class="n">NewElemental</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Back</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">BreadthQueueNodeSetNext</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Back</span><span class="p">,</span> <span class="n">Noob</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span> <span class="o">=</span> <span class="n">Noob</span><span class="p">;</span>
    <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Back</span> <span class="o">=</span> <span class="n">Noob</span><span class="p">;</span>
    <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TnodePtr</span> <span class="nf">BreadthQueuePop</span><span class="p">(</span><span class="n">BreadthQueuePtr</span> <span class="n">ThisBreadthQueue</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Back</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">TnodePtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Element</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span><span class="p">);</span>
        <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">TnodePtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Element</span><span class="p">;</span>
    <span class="n">BreadthQueueNodePtr</span> <span class="n">Holder</span> <span class="o">=</span> <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span><span class="p">;</span>
    <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Front</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">Holder</span><span class="p">);</span>
    <span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// For the "Tnode" "Dangling" process, arrange the "Tnodes" in the "Holder" array, with breadth-first traversal order.</span>
<span class="kt">void</span> <span class="nf">BreadthQueuePopulateReductionArray</span><span class="p">(</span><span class="n">BreadthQueuePtr</span> <span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Root</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="o">****</span><span class="n">Holder</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">InsertionPosition</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">CMCD</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">CLetterIndex</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">CDCstatus</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">InsertionPosition</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">MAX</span><span class="o">*</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">TnodePtr</span> <span class="n">Current</span> <span class="o">=</span> <span class="n">Root</span><span class="p">;</span>
    <span class="c1">// Push the first row onto the queue.</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">BreadthQueuePush</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">Current</span><span class="p">);</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Initiate the pop followed by push all children loop.</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">BreadthQueuePop</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="p">);</span>
        <span class="n">CMCD</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">MaxChildDepth</span><span class="p">;</span>
        <span class="n">CLetterIndex</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">LetterIndex</span><span class="p">;</span>
        <span class="n">CDCstatus</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">DirectChild</span><span class="p">;</span>
        <span class="n">Holder</span><span class="p">[</span><span class="n">CMCD</span><span class="p">][</span><span class="n">CLetterIndex</span><span class="p">][</span><span class="n">CDCstatus</span><span class="p">][</span><span class="n">InsertionPosition</span><span class="p">[</span><span class="n">CMCD</span><span class="p">][</span><span class="n">CLetterIndex</span><span class="p">][</span><span class="n">CDCstatus</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Current</span><span class="p">;</span>
        <span class="n">InsertionPosition</span><span class="p">[</span><span class="n">CMCD</span><span class="p">][</span><span class="n">CLetterIndex</span><span class="p">][</span><span class="n">CDCstatus</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">TnodeChild</span><span class="p">(</span><span class="n">Current</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">BreadthQueuePush</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">Current</span><span class="p">);</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">TnodeNext</span><span class="p">(</span><span class="n">Current</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// It is of absolutely critical importance that only "DirectChild" nodes are pushed onto the queue as child nodes.</span>
<span class="c1">// This will not always be the case.</span>
<span class="c1">// In a DAWG, a child pointer may point to an internal node in a longer list.  Check for this.</span>
<span class="kt">int</span> <span class="nf">BreadthQueueUseToIndex</span><span class="p">(</span><span class="n">BreadthQueuePtr</span> <span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">Root</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">IndexNow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">Current</span> <span class="o">=</span> <span class="n">Root</span><span class="p">;</span>
    <span class="c1">// Push the first row onto the queue.</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">BreadthQueuePush</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">Current</span><span class="p">);</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Pop each element off of the queue and only push its children if its first "Child" is a "DirectChild", without a set "ArrayIndex".</span>
    <span class="c1">// Assign index if one has not been given to it yet.</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">BreadthQueuePop</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="p">);</span>
        <span class="c1">// A traversal of the Trie will never land on "Dangling" "Tnodes", but it will try to visit certain "Tnodes" many times.</span>
        <span class="c1">// Even if we only "Push" "Tnode"s without an assigned "ArrayIndex", many "Tnode"s will have this value set while in the queue.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">TnodeArrayIndex</span><span class="p">(</span><span class="n">Current</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">IndexNow</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">TnodeSetArrayIndex</span><span class="p">(</span><span class="n">Current</span><span class="p">,</span> <span class="n">IndexNow</span><span class="p">);</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">TnodeChild</span><span class="p">(</span><span class="n">Current</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                <span class="c1">// The graph will lead to intermediate positions, but we cannot start numbering "Tnodes" from the middle of a list.</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">TnodeDirectChild</span><span class="p">(</span><span class="n">Current</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="o">&amp;&amp;</span> <span class="n">TnodeArrayIndex</span><span class="p">(</span><span class="n">Current</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">TnodeArrayIndex</span><span class="p">(</span><span class="n">Current</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Pushed Tnode with a non-zero ArrayIndex.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="n">BreadthQueuePush</span><span class="p">(</span><span class="n">ThisBreadthQueue</span><span class="p">,</span> <span class="n">Current</span><span class="p">);</span>
                        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">IndexNow</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Next and Child become indices.</span>
<span class="k">struct</span> <span class="n">arraydnode</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">Next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Child</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">LetterIndex</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">EndOfWordFlag</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">Level</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ChildCount</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Position</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">arraydnode</span> <span class="n">ArrayDnode</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ArrayDnode</span><span class="o">*</span> <span class="n">ArrayDnodePtr</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">ArrayDnodeInit</span><span class="p">(</span><span class="n">ArrayDnodePtr</span> <span class="n">ThisArrayDnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Chap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Nextt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Childd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">EndingFlag</span><span class="p">,</span> <span class="kt">char</span> <span class="n">Breadth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Posit</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Ccount</span><span class="p">){</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">=</span> <span class="n">Chap</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span> <span class="o">=</span> <span class="n">EndingFlag</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">Nextt</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">Childd</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="n">Breadth</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Position</span> <span class="o">=</span> <span class="n">Posit</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">ChildCount</span> <span class="o">=</span> <span class="n">Ccount</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ArrayDnodeTnodeTranspose</span><span class="p">(</span><span class="n">ArrayDnodePtr</span> <span class="n">ThisArrayDnode</span><span class="p">,</span> <span class="n">TnodePtr</span> <span class="n">ThisTnode</span><span class="p">){</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">LetterIndex</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">EndOfWordFlag</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Position</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">DistanceToEndOfList</span><span class="p">;</span>
    <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">ChildCount</span> <span class="o">=</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">NumberOfChildren</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArrayIndex</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">ThisArrayDnode</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThisTnode</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArrayIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">arraydawg</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">NumberOfStrings</span><span class="p">;</span>
    <span class="n">ArrayDnodePtr</span> <span class="n">DawgArray</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">First</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">arraydawg</span> <span class="n">ArrayDawg</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ArrayDawg</span><span class="o">*</span> <span class="n">ArrayDawgPtr</span><span class="p">;</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// This function is the core of the DAWG creation procedure.  Pay close attention to the order of the steps involved.</span>

<span class="n">ArrayDawgPtr</span> <span class="nf">ArrayDawgInit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">Dictionary</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">SegmentLenghts</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Z</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">W</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Step 0 - Allocate the framework for the intermediate Array-Data-Structure.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// Dynamically allocate the upper Data-Structure.</span>
    <span class="n">ArrayDawgPtr</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArrayDawgPtr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArrayDawg</span><span class="p">));</span>
    <span class="c1">// Set NumberOfStrings.</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">NumberOfStrings</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;=</span> <span class="n">MAX</span> <span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">NumberOfStrings</span> <span class="o">+=</span> <span class="n">SegmentLenghts</span><span class="p">[</span><span class="n">X</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 1 - Create a TemporaryTrie and begin filling it with the |%d| words.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">NumberOfStrings</span><span class="p">);</span>
    <span class="c1">/// Create a Temp Trie structure and then feed in the given dictionary.</span>
    <span class="n">DawgPtr</span> <span class="n">TemporaryTrie</span> <span class="o">=</span> <span class="n">DawgInit</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;=</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">SegmentLenghts</span><span class="p">[</span><span class="n">Y</span><span class="p">];</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">DawgAddWord</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">[</span><span class="n">Y</span><span class="p">][</span><span class="n">Y</span><span class="o">*</span><span class="n">X</span><span class="p">]),</span> <span class="n">Y</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 2 - Finished filling TemporaryTrie, so calculate the InternalValues comparison integers.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">TnodeCalculateInternalValuesRecurse</span><span class="p">(</span><span class="n">DawgRootNode</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">));</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 3 - Eliminate recursion by calculating the recursive CrcDigest for each Tnode.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">TnodeCalculateCrcDigestRecurse</span><span class="p">(</span><span class="n">DawgRootNode</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">));</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 4 - Count Tnodes into 780 groups, segmented by MaxChildDepth, Letter, and DirectChild.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Allocate 3D arrays of "int"s to count the "Tnodes" into groups.</span>
    <span class="kt">int</span> <span class="o">***</span><span class="n">NodeGroupCounter</span><span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">***</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MAX</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">));</span>
    <span class="kt">int</span> <span class="o">***</span><span class="n">NodeGroupCounterInit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">***</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MAX</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
        <span class="n">NodeGroupCounter</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
            <span class="n">NodeGroupCounter</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">DawgGraphTabulate</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">,</span> <span class="n">NodeGroupCounterInit</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 5 - Initial Tnode counting is complete, so display results:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">TotalNodeSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">MaxGroupSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">CurrentGroupSize</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">CurrentGroupSize</span> <span class="o">=</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">TotalNodeSum</span> <span class="o">+=</span> <span class="n">CurrentGroupSize</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentGroupSize</span> <span class="o">&gt;</span> <span class="n">MaxGroupSize</span> <span class="p">)</span> <span class="n">MaxGroupSize</span> <span class="o">=</span> <span class="n">CurrentGroupSize</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Total Tnode Count For The Raw-Trie = |%d|, MaxGroupSize = |%d| </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TotalNodeSum</span><span class="p">,</span> <span class="n">MaxGroupSize</span><span class="p">);</span>
    <span class="c1">// We will have exactly enough space for all of the Tnode pointers.</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 6 - Allocate a 4-D array of Tnode pointers to tag redundant Tnodes for replacement.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">TnodePtr</span> <span class="o">****</span><span class="n">HolderOfAllTnodePointers</span> <span class="o">=</span> <span class="p">(</span><span class="n">TnodePtr</span> <span class="o">****</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MAX</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="o">***</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TnodePtr</span> <span class="o">***</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="o">**</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TnodePtr</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span> <span class="o">*</span><span class="p">));</span>
            <span class="n">CurrentGroupSize</span> <span class="o">=</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentGroupSize</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TnodePtr</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">CurrentGroupSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
                <span class="k">else</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// A breadth-first traversal is used when populating the final array.</span>
    <span class="c1">// It is then much more likely for living "Tnode"s to appear first, if we fill "HolderOfAllTnodePointers" breadth first.</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 7 - Populate the 4 dimensional Tnode pointer array, keeping DirectChild nodes closer to the end.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// Use a breadth first traversal to populate the "HolderOfAllTnodePointers" array.</span>
    <span class="n">BreadthQueuePtr</span> <span class="n">Populator</span> <span class="o">=</span> <span class="n">BreadthQueueInit</span><span class="p">();</span>
    <span class="n">BreadthQueuePopulateReductionArray</span><span class="p">(</span><span class="n">Populator</span><span class="p">,</span> <span class="n">DawgRootNode</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">),</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">Populator</span><span class="p">);</span>

    <span class="c1">// "HolderOfAllTnodePointers" Population procedure is complete.</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 8 - Use the stable Merge-Sort algorithm to sort [MaxChildDepth][LetterIndex] groups by CrcDigest values.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">TnodePtr</span> <span class="o">*</span><span class="n">SupplementalArray</span> <span class="o">=</span> <span class="p">(</span><span class="n">TnodePtr</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MaxGroupSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TnodePtr</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">TnodeArrayMergeSortRecurse</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">SupplementalArray</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">SupplementalArray</span><span class="p">);</span>

    <span class="c1">// Flag all of the reduntant "Tnode"s, and store a "ReplaceMeWith" "Tnode" reference inside the "Dangling" "Tnode"s.</span>
    <span class="c1">// "Tnode"s are compared using their "CrcDigest" values, which incorporate information from entire branch structures.</span>
    <span class="kt">int</span> <span class="n">NumberDangled</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">DangledNow</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">DirectDangled</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">TotalDangled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CurrentCrcDigest</span><span class="p">;</span>
    <span class="n">TnodePtr</span> <span class="n">CorrectReplacementTnode</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 9 - Tag entire Tnode branch structures as Dangling - Elimination begins with DirectChild Tnodes and filters down:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  This procedure is at the very heart of DAWG genesis, where the Blitzkrieg Algorithm shines with CRC, and Tnode Segmentation.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  Seperate groups exist for each [MaxChildDepth]-[LetterIndex] pair.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  Groups of similar Tnodes, are now sorted by 3 values, [BreadthFirst], [DirectChild], [CrcDigest].</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  This Blitzkrieg Scheme means that each redundant Tnode patch will directly follow its living Tnode replacement.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  ---------------------------------------------------------------------------------------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// "X" is the current "MaxChildDepth".</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="n">MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">NumberDangled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">DirectDangled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// "Y" is the current "LetterIndex", starting at "0".</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">CurrentGroupSize</span> <span class="o">=</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">CorrectReplacementTnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">CurrentCrcDigest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">// "Z" Will move through the current "Tnode" group, identifying the "CorrectReplacementTnode".</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Z</span> <span class="o">&lt;</span> <span class="n">CurrentGroupSize</span><span class="p">;</span> <span class="n">Z</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                <span class="n">CorrectReplacementTnode</span> <span class="o">=</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">Z</span><span class="p">];</span>
                <span class="n">CurrentCrcDigest</span> <span class="o">=</span> <span class="n">CorrectReplacementTnode</span><span class="o">-&gt;</span><span class="n">CrcDigest</span><span class="p">;</span>
                <span class="c1">// "W" Tracks the "Tnodes" that will be Dangled, and shifts "Z" when it finds a new "CrcDigest".</span>
                <span class="k">for</span> <span class="p">(</span> <span class="n">W</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">W</span> <span class="o">&lt;</span> <span class="n">CurrentGroupSize</span><span class="p">;</span> <span class="n">W</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">CrcDigest</span> <span class="o">==</span> <span class="n">CurrentCrcDigest</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Dangling</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">DirectChild</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                        <span class="c1">// If the potential replacement "Tnode" has "Protected" "Tnode"s under it, then proceed to exchange the offending branch.</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="p">)</span> <span class="p">{</span>
                            <span class="n">printf</span><span class="p">(</span><span class="s">"  Attempting to Dangle Protected, Count = |%d|"</span><span class="p">,</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span><span class="p">);</span>
                            <span class="n">TnodeExchangeProtectedNodeRecurse</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">],</span> <span class="n">CorrectReplacementTnode</span><span class="p">);</span>
                            <span class="c1">//printf(", after swap Count = |%d|.\n", HolderOfAllTnodePointers[X][Y][2][W]-&gt;ProtectedUnderCount);</span>
                            <span class="k">if</span> <span class="p">(</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ProtectedUnderCount</span> <span class="p">)</span> <span class="p">{</span>
                                <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Exchanging the first protected Tnode did not solve the problem.  Fix the Exchange procedure.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>
                            <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">" - FIXED.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="p">}</span>
                        <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ReplaceMeWith</span> <span class="o">=</span> <span class="n">CorrectReplacementTnode</span><span class="p">;</span>
                        <span class="n">TnodeProtect</span><span class="p">(</span><span class="n">CorrectReplacementTnode</span><span class="p">);</span>
                        <span class="n">DirectDangled</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">DangledNow</span> <span class="o">=</span> <span class="n">TnodeDangleRecurse</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]);</span>
                        <span class="n">NumberDangled</span> <span class="o">+=</span> <span class="n">DangledNow</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="p">{</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  DirectDangled |%5d| Tnodes, and |%5d| through recursion - MCD|%2d|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DirectDangled</span><span class="p">,</span> <span class="n">NumberDangled</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
        <span class="n">TotalDangled</span> <span class="o">+=</span> <span class="n">NumberDangled</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  ---------------------------------------------------------------------------------------------------------------------------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">NumberOfLivingNodes</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  |%6d| = Original # of Tnodes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TotalNodeSum</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  |%6d| = Dangled # of Tnodes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TotalDangled</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  |%6d| = Remaining # of Tnodes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfLivingNodes</span> <span class="o">=</span> <span class="n">TotalNodeSum</span> <span class="o">-</span> <span class="n">TotalDangled</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 10 - Count the number of living Tnodes by traversing the Raw-Trie to check the Dangling numbers.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">DawgGraphTabulate</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">,</span> <span class="n">NodeGroupCounter</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">TotalDangledCheck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Z</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">Z</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">TotalDangledCheck</span> <span class="o">+=</span> <span class="p">(</span><span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span> <span class="o">-</span> <span class="n">NodeGroupCounter</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="n">Z</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">TotalDangled</span> <span class="o">==</span> <span class="n">TotalDangledCheck</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"  Tnode Dangling count is consistent, TotalDangledCheck = |%d|.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TotalDangledCheck</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">"  MISMATCH for Tnode Dangling count.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">step 11 - Using the BlitzkriegTrieAttack, substitute Dangling Tnodes with internal </span><span class="se">\"</span><span class="s">ReplaceMeWith</span><span class="se">\"</span><span class="s"> values.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// Node replacement has to take place before indices are set up, so nothing points to redundant nodes.</span>
    <span class="c1">// This step is absolutely critical.  Attack the Raw Trie using the Blitzkrieg single penetration.  Then Index.</span>
    <span class="n">BlitzkriegTrieAttack</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Killing complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 12 - Blitzkrieg Attack is victorious, so assign array indicies to all living Tnodes using a Breadth-First-Queue.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">BreadthQueuePtr</span> <span class="n">OrderMatters</span> <span class="o">=</span> <span class="n">BreadthQueueInit</span><span class="p">();</span>
    <span class="c1">// The Breadth-First-Queue must assign an index value to each living "Tnode" only once.</span>
    <span class="c1">// Make sure to feed the root Tnode of "TemporaryTrie" into the "BreadthQueueUseToIndex()" function.</span>
    <span class="kt">int</span> <span class="n">IndexCount</span> <span class="o">=</span> <span class="n">BreadthQueueUseToIndex</span><span class="p">(</span><span class="n">OrderMatters</span><span class="p">,</span> <span class="n">DawgRootNode</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">));</span>
    <span class="n">free</span><span class="p">(</span><span class="n">OrderMatters</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Index assignment is now complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  |%d| = NumberOfLivingNodes from after the Dangling process.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfLivingNodes</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  |%d| = IndexCount from the breadth-first assignment function.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">IndexCount</span><span class="p">);</span>

    <span class="c1">// Allocate the space needed to store the "DawgArray".</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArrayDnodePtr</span><span class="p">)</span><span class="n">calloc</span><span class="p">((</span><span class="n">NumberOfLivingNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ArrayDnode</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">IndexFollow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">IndexFollower</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">TransposeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Roll through the pointer arrays and use the "ArrayDnodeTnodeTranspose" function to populate it.</span>
    <span class="c1">// Set the dummy entry at the beginning of the array.</span>
    <span class="n">ArrayDnodeInit</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">Result</span><span class="o">-&gt;</span><span class="n">First</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 13 - Populate the new Working-Array-Dawg structure, used to verify validity and create the final integer-graph-encodings.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// Scroll through "HolderOfAllTnodePointers" and look for un"Dangling" "Tnodes", if so then transpose them into "Result-&gt;DawgArray".</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="n">MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Z</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">Z</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span> <span class="n">W</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">W</span> <span class="o">&lt;</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="n">Z</span><span class="p">];</span> <span class="n">W</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">TnodeDangling</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="n">Z</span><span class="p">][</span><span class="n">W</span><span class="p">])</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">IndexFollow</span> <span class="o">=</span> <span class="n">TnodeArrayIndex</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="n">Z</span><span class="p">][</span><span class="n">W</span><span class="p">]);</span>
                        <span class="n">ArrayDnodeTnodeTranspose</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">IndexFollow</span><span class="p">]),</span> <span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="n">Z</span><span class="p">][</span><span class="n">W</span><span class="p">]);</span>
                        <span class="n">TransposeCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">IndexFollow</span> <span class="o">&gt;</span> <span class="n">IndexFollower</span> <span class="p">)</span> <span class="n">IndexFollower</span> <span class="o">=</span> <span class="n">IndexFollow</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  |%d| = IndexFollower, which is the largest index assigned in the Working-Array-Dawg.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">IndexFollower</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  |%d| = TransposeCount, holds the number of Tnodes transposed into the Working-Array-Dawg.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TransposeCount</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  |%d| = NumberOfLivingNodes.  Make sure that these three values are equal, because they must be.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfLivingNodes</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">IndexFollower</span> <span class="o">==</span> <span class="n">TransposeCount</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">IndexFollower</span> <span class="o">==</span> <span class="n">NumberOfLivingNodes</span><span class="p">)</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Equality assertion passed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Equality assertion failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Conduct dynamic-memory-cleanup and free the whole Raw-Trie, which is no longer needed.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="n">MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">W</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">W</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeGroupCounterInit</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span> <span class="n">W</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">free</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">W</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">Y</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">HolderOfAllTnodePointers</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">TemporaryTrie</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 14 - Creation of the traditional-DAWG is complete, so store it in a binary file for use.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">FILE</span> <span class="o">*</span><span class="n">Data</span><span class="p">;</span>
    <span class="n">Data</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span> <span class="n">TRADITIONAL_DAWG_DATA</span><span class="p">,</span><span class="s">"wb"</span> <span class="p">);</span>
    <span class="c1">// The "NULL" node in position "0" must be counted now.</span>
    <span class="kt">int</span> <span class="n">CurrentNodeInteger</span> <span class="o">=</span> <span class="n">NumberOfLivingNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// It is critical, especially in a binary file, that the first integer written to the file be the number of nodes stored in the file.</span>
    <span class="n">fwrite</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">CurrentNodeInteger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Data</span> <span class="p">);</span>
    <span class="c1">// Write the "NULL" node to the file first.</span>
    <span class="n">CurrentNodeInteger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fwrite</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">CurrentNodeInteger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Data</span> <span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;=</span> <span class="n">NumberOfLivingNodes</span> <span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">){</span>
        <span class="n">CurrentNodeInteger</span> <span class="o">=</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">)[</span><span class="n">X</span><span class="p">].</span><span class="n">Child</span><span class="p">;</span>
        <span class="n">CurrentNodeInteger</span> <span class="o">&lt;&lt;=</span> <span class="n">CHILD_BIT_SHIFT</span><span class="p">;</span>
        <span class="n">CurrentNodeInteger</span> <span class="o">|=</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">LetterIndex</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">EndOfWordFlag</span> <span class="p">)</span> <span class="n">CurrentNodeInteger</span> <span class="o">|=</span> <span class="n">END_OF_WORD_BIT_MASK</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">Next</span> <span class="p">)</span> <span class="n">CurrentNodeInteger</span> <span class="o">|=</span> <span class="n">END_OF_LIST_BIT_MASK</span><span class="p">;</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CurrentNodeInteger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"</span><span class="se">\n</span><span class="s">  The Traditional-DAWG-Encoding data file is now written.</span><span class="se">\n</span><span class="s">"</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 15 - Output a text file with all the node information explicitly layed out.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">FILE</span> <span class="o">*</span><span class="n">Text</span><span class="p">;</span>
    <span class="n">Text</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">TRADITIONAL_DAWG_TEXT_DATA</span><span class="p">,</span><span class="s">"w"</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">TheNodeInBinary</span><span class="p">[</span><span class="mi">32</span><span class="o">+</span><span class="mi">5</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">CompleteThirtyTwoBitNode</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">"Behold, the |%d| Traditional DAWG nodes are decoded below:</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfLivingNodes</span><span class="p">);</span>

    <span class="c1">// We are now ready to output to the text file, and the "Main" binary data file.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;=</span> <span class="n">NumberOfLivingNodes</span> <span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">){</span>
        <span class="n">CompleteThirtyTwoBitNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">)[</span><span class="n">X</span><span class="p">].</span><span class="n">Child</span><span class="p">;</span>
        <span class="n">CompleteThirtyTwoBitNode</span> <span class="o">&lt;&lt;=</span> <span class="n">CHILD_BIT_SHIFT</span><span class="p">;</span>
        <span class="n">CompleteThirtyTwoBitNode</span> <span class="o">|=</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">LetterIndex</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">)[</span><span class="n">X</span><span class="p">].</span><span class="n">EndOfWordFlag</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="n">CompleteThirtyTwoBitNode</span> <span class="o">|=</span> <span class="n">END_OF_WORD_BIT_MASK</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">)[</span><span class="n">X</span><span class="p">].</span><span class="n">Next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">CompleteThirtyTwoBitNode</span> <span class="o">|=</span> <span class="n">END_OF_LIST_BIT_MASK</span><span class="p">;</span>
        <span class="n">ConvertIntNodeToBinaryString</span><span class="p">(</span><span class="n">CompleteThirtyTwoBitNode</span><span class="p">,</span> <span class="n">TheNodeInBinary</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">"N%6d-%s, DistanceToEndOfList|%2d|"</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">TheNodeInBinary</span><span class="p">,</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">Position</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">", NumberOfChildren|%2d|"</span><span class="p">,</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">ChildCount</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">", Lev|%2d|"</span><span class="p">,</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">)[</span><span class="n">X</span><span class="p">].</span><span class="n">Level</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">", {'%c',%d,%6d"</span><span class="p">,</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">LetterIndex</span><span class="p">],</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">EndOfWordFlag</span><span class="p">,</span> <span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">[</span><span class="n">X</span><span class="p">].</span><span class="n">Next</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">",%6d}"</span><span class="p">,</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">DawgArray</span><span class="p">)[</span><span class="n">X</span><span class="p">].</span><span class="n">Child</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">".</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">CompleteThirtyTwoBitNode</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Error in node encoding process.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">Number Of Living Nodes |%d| Plus The NULL Node.</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfLivingNodes</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">Text</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ThisLine</span><span class="p">[</span><span class="n">INPUT_LIMIT</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Hit </span><span class="se">\"</span><span class="s">Enter</span><span class="se">\"</span><span class="s"> to begin the Blitzkrieg Attack Algorithm:</span><span class="se">\n\n</span><span class="s">  Be dazzled, your DAWG will be created in the PAST:"</span><span class="p">);</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">,</span> <span class="n">INPUT_LIMIT</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="c1">// All of the words of similar length will be stored sequentially in the same array so that there will be (MAX + 1)  arrays in total.</span>
    <span class="c1">// The Smallest length of a string is assumed to be 2.</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">AllWordsInEnglish</span><span class="p">[</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">AllWordsInEnglish</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Read the precompiled lookup-table from "CRC-32.dat" directly into "TheLookupTable".</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">TableFile</span><span class="p">;</span>
    <span class="n">TableFile</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">LOOKUP_TABLE_DATA</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">TheLookupTable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">TWO_UP_EIGHT</span><span class="p">,</span> <span class="n">TableFile</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">TableFile</span><span class="p">);</span>

    <span class="kt">FILE</span> <span class="o">*</span><span class="n">Input</span><span class="p">;</span>
    <span class="n">Input</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">RAW_LEXICON</span><span class="p">,</span><span class="s">"r"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">FirstLineIsSize</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">LineLength</span><span class="p">;</span>

    <span class="n">fgets</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">,</span> <span class="n">INPUT_LIMIT</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>
    <span class="n">CutOffExtraChars</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">);</span>
    <span class="n">FirstLineIsSize</span> <span class="o">=</span> <span class="n">StringToPositiveInt</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  FirstLineIsSize = Number-Of-Words = |%d|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">FirstLineIsSize</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">DictionarySizeIndex</span><span class="p">[</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;=</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">DictionarySizeIndex</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">LexiconInRam</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">FirstLineIsSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>

    <span class="c1">// The first line is the Number-Of-Words, so read them all into RAM, temporarily.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">FirstLineIsSize</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">fgets</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">,</span> <span class="n">INPUT_LIMIT</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>
        <span class="n">CutOffExtraChars</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">);</span>
        <span class="n">MakeMeAllCapital</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">TestForValidWord</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">)</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Invalid Word @ |%d|-|%s|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">ThisLine</span><span class="p">);</span>
        <span class="n">LineLength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ThisLine</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">LineLength</span> <span class="o">&lt;=</span> <span class="n">MAX</span> <span class="p">)</span> <span class="n">DictionarySizeIndex</span><span class="p">[</span><span class="n">LineLength</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"The word in position |%d| is too long.  EXIT.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LexiconInRam</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">LineLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">));</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">LexiconInRam</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">ThisLine</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Word-List.txt is now in RAM.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// Allocate enough space to hold all of the words in "unsigned char" arrays holding character indexes.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">AllWordsInEnglish</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">DictionarySizeIndex</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">CurrentTracker</span><span class="p">[</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">CurrentTracker</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">CurrentWordByIndex</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">CurrentLength</span><span class="p">;</span>
    <span class="c1">// Copy all of the words into the "LetterIndex" format "AllWordsInEnglish" array.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">FirstLineIsSize</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">CurrentLength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">LexiconInRam</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
        <span class="c1">// Convert each string from its temporary ram location into the "LetterIndex" format, and copy that into "AllWordsInEnglish".</span>
        <span class="n">LettersToIndexConversion</span><span class="p">(</span><span class="n">LexiconInRam</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">CurrentWordByIndex</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">AllWordsInEnglish</span><span class="p">[</span><span class="n">CurrentLength</span><span class="p">]</span> <span class="o">+</span> <span class="n">CurrentTracker</span><span class="p">[</span><span class="n">CurrentLength</span><span class="p">]</span><span class="o">*</span><span class="n">CurrentLength</span><span class="p">,</span> <span class="n">CurrentWordByIndex</span><span class="p">,</span> <span class="n">CurrentLength</span><span class="p">);</span>
        <span class="n">CurrentTracker</span><span class="p">[</span><span class="n">CurrentLength</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  The words are now stored in an array according to length.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// Make sure that the counting has resulted in all of the strings being placed correctly.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">DictionarySizeIndex</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">CurrentTracker</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"  |%2d| Letter word count = |%5d| is verified.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">CurrentTracker</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
        <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">"  Something went wrong with |%2d| letter words.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Free the the initial dynamically allocated memory.</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">FirstLineIsSize</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">LexiconInRam</span><span class="p">[</span><span class="n">X</span><span class="p">]);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">LexiconInRam</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  Begin Creator init function.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">ArrayDawgPtr</span> <span class="n">Adoggy</span> <span class="o">=</span> <span class="n">ArrayDawgInit</span><span class="p">(</span><span class="n">AllWordsInEnglish</span><span class="p">,</span> <span class="n">DictionarySizeIndex</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Step 16 - Display the Mask-Format for the DAWG int-nodes:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">Something</span><span class="p">[</span><span class="mi">32</span><span class="o">+</span><span class="mi">5</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

    <span class="n">ConvertIntNodeToBinaryString</span><span class="p">(</span><span class="n">CHILD_INDEX_BIT_MASK</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  %s - CHILD_INDEX_BIT_MASK</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>

    <span class="n">ConvertIntNodeToBinaryString</span><span class="p">(</span><span class="n">END_OF_WORD_BIT_MASK</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  %s - END_OF_WORD_BIT_MASK</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>

    <span class="n">ConvertIntNodeToBinaryString</span><span class="p">(</span><span class="n">END_OF_LIST_BIT_MASK</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  %s - END_OF_LIST_BIT_MASK</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>

    <span class="n">ConvertIntNodeToBinaryString</span><span class="p">(</span><span class="n">LETTER_BIT_MASK</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  %s - LETTER_BIT_MASK</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Something</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="blitzkrieg_functionality_test"><a class="anchor" href="#blitzkrieg_functionality_test"></a>Blitzkrieg Functionality Test</h3>
<div class="listingblock small">
<div class="title"><a href="./src-c-latest/Blitzkrieg_Functionality_Test.c" title="View source file" target="_blank" rel="noopener">&#8220;Blitzkrieg_Functionality_Test.c&#8221;</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// This program tests the validity of a Blitzkrieg DAWG file, and demonstrates the new Dawg-Node configuration.</span>
<span class="c1">// Updated on Monday, December 29, 2011.</span>

<span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="cp">#define MAX 15
#define MAX_INPUT 120
#define BIG_IT_UP -32
#define LOWER_IT 32
#define SIZE_OF_CHARACTER_SET 26
#define WILD_CARD '?'
#define DAWG_DATA "Traditional_Dawg_For_Word-List.dat"
#define WORD_LIST_OUTPUT "New_Dawg_Word_List.txt"
</span>
<span class="c1">// These values define the format of the "Dawg" node encoding.</span>
<span class="cp">#define CHILD_BIT_SHIFT 10
#define END_OF_WORD_BIT_MASK 0X00000200
#define END_OF_LIST_BIT_MASK 0X00000100
#define LETTER_BIT_MASK 0X000000FF
</span>
<span class="c1">// Define the boolean type as an enumeration.</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">FALSE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TRUE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}</span> <span class="n">Bool</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Bool</span><span class="o">*</span> <span class="n">BoolPtr</span><span class="p">;</span>

<span class="c1">// When reading strings from a file, the new-line character is appended, and this macro will remove it before processing.</span>
<span class="cp">#define CUT_OFF_NEW_LINE(string) (string[strlen(string) - 1] = '\0')
</span>
<span class="c1">// For speed, define these two simple functions as macros.  They modify the "LettersToWorkWith" string in the recursive anagrammer.</span>
<span class="cp">#define REMOVE_CHAR_FROM_STRING(thestring, theposition, shiftsize) ( memmove(thestring + theposition, thestring + theposition + 1, shiftsize) )
#define INSERT_CHAR_IN_STRING(ts, tp, thechar, shiftsize) ( (memmove(ts + tp + 1, ts + tp, shiftsize)), (ts[tp] = thechar) )
</span>
<span class="c1">// These are the predefined characters that exist in the DAWG data file.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">,</span> <span class="sc">'D'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'F'</span><span class="p">,</span> <span class="sc">'G'</span><span class="p">,</span> <span class="sc">'H'</span><span class="p">,</span> <span class="sc">'I'</span><span class="p">,</span> <span class="sc">'J'</span><span class="p">,</span> <span class="sc">'K'</span><span class="p">,</span>
 <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'M'</span><span class="p">,</span> <span class="sc">'N'</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'P'</span><span class="p">,</span> <span class="sc">'Q'</span><span class="p">,</span> <span class="sc">'R'</span><span class="p">,</span> <span class="sc">'S'</span><span class="p">,</span> <span class="sc">'T'</span><span class="p">,</span> <span class="sc">'U'</span><span class="p">,</span> <span class="sc">'V'</span><span class="p">,</span> <span class="sc">'W'</span><span class="p">,</span> <span class="sc">'X'</span><span class="p">,</span> <span class="sc">'Y'</span><span class="p">,</span> <span class="sc">'Z'</span> <span class="p">};</span>

<span class="c1">// Enter the graph at the correct position without scrolling through a predefined list of level "0" nodes.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EntryNodeIndex</span><span class="p">[</span><span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span>
 <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span> <span class="p">};</span>

<span class="c1">// This function converts any lower case letters in the string "RawWord", into capitals, so that the whole string is made of capital letters.</span>
<span class="kt">void</span> <span class="nf">MakeMeAllCapital</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">RawWord</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">RawWord</span><span class="p">);</span> <span class="n">X</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'z'</span> <span class="p">)</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">RawWord</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">+</span> <span class="n">BIG_IT_UP</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function removes any char from "ThisString" which does not exist in "CharacterSet".</span>
<span class="kt">void</span> <span class="nf">RemoveIllegalChars</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ThisString</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ThisString</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisString</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">WILD_CARD</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">CheckNextPosition</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">ThisString</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">CheckNextPosition</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// The "char" in position "X" is illegal.</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">ThisString</span> <span class="o">+</span> <span class="n">X</span><span class="p">,</span> <span class="n">ThisString</span> <span class="o">+</span> <span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Length</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
        <span class="n">X</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">Length</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nl">CheckNextPosition:</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Return the index position of character "ThisChar", as it appears in "CharacterSet", and it must exist in the set.</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">CharToIndexConversion</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ThisChar</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ThisChar</span> <span class="o">==</span> <span class="n">WILD_CARD</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">255</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ThisChar</span> <span class="o">==</span> <span class="n">CharacterSet</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span> <span class="p">)</span> <span class="k">return</span> <span class="n">Y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This is a simple Bubble Sort.</span>
<span class="kt">void</span> <span class="nf">Alphabetize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Word</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">WildCardCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">WorkingChar</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">WordSize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">Word</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">WordSize</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">WordSize</span> <span class="o">-</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">CharToIndexConversion</span><span class="p">(</span><span class="n">Word</span><span class="p">[</span><span class="n">Y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">CharToIndexConversion</span><span class="p">(</span><span class="n">Word</span><span class="p">[</span><span class="n">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">WorkingChar</span> <span class="o">=</span> <span class="n">Word</span><span class="p">[</span><span class="n">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">Word</span><span class="p">[</span><span class="n">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Word</span><span class="p">[</span><span class="n">Y</span><span class="p">];</span>
                <span class="n">Word</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">WorkingChar</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Word</span><span class="p">[</span><span class="n">WordSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">WILD_CARD</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">Word</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">WILD_CARD</span> <span class="p">)</span> <span class="n">WildCardCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">Word</span> <span class="o">+</span> <span class="n">WildCardCount</span><span class="p">,</span> <span class="n">Word</span><span class="p">,</span> <span class="n">WordSize</span> <span class="o">-</span> <span class="n">WildCardCount</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">Word</span><span class="p">,</span> <span class="n">WILD_CARD</span><span class="p">,</span> <span class="n">WildCardCount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Define the "Dawg" functionality as macros for speed.  "DAWG_CHILD()" Now uses only a single bit shift operation.</span>
<span class="cp">#define DAWG_LETTER(thearray, theindex) (thearray[theindex]&amp;LETTER_BIT_MASK)
#define DAWG_END_OF_WORD(thearray, theindex) (thearray[theindex]&amp;END_OF_WORD_BIT_MASK)
#define DAWG_NEXT(thearray, theindex) ((thearray[theindex]&amp;END_OF_LIST_BIT_MASK)? 0: theindex + 1)
#define DAWG_CHILD(thearray, theindex) (thearray[theindex]&gt;&gt;CHILD_BIT_SHIFT)
</span>
<span class="c1">// A recursive depth first traversal of "TheDawg" lexicon to produce a readable wordlist in "TheStream".</span>
<span class="kt">void</span> <span class="nf">DawgTraverseLexiconRecurse</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">TheDawg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">CurrentIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FillThisPosition</span><span class="p">,</span>
 <span class="kt">char</span> <span class="o">*</span><span class="n">WorkingString</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">TheCount</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">TheStream</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">PassOffIndex</span><span class="p">;</span>
    <span class="n">WorkingString</span><span class="p">[</span><span class="n">FillThisPosition</span><span class="p">]</span> <span class="o">=</span> <span class="n">DAWG_LETTER</span><span class="p">(</span><span class="n">TheDawg</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">DAWG_END_OF_WORD</span><span class="p">(</span><span class="n">TheDawg</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">TheCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">WorkingString</span><span class="p">[</span><span class="n">FillThisPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="c1">// Include the Windows Carriage Return char.</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">TheStream</span><span class="p">,</span> <span class="s">"|%6d|-|%-15s|</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">TheCount</span><span class="p">,</span> <span class="n">WorkingString</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">PassOffIndex</span> <span class="o">=</span> <span class="n">DAWG_CHILD</span><span class="p">(</span><span class="n">TheDawg</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">)</span> <span class="p">)</span> <span class="n">DawgTraverseLexiconRecurse</span><span class="p">(</span><span class="n">TheDawg</span><span class="p">,</span>
    <span class="n">PassOffIndex</span><span class="p">,</span> <span class="n">FillThisPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">WorkingString</span><span class="p">,</span> <span class="n">TheCount</span><span class="p">,</span> <span class="n">TheStream</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">PassOffIndex</span> <span class="o">=</span> <span class="n">DAWG_NEXT</span><span class="p">(</span><span class="n">TheDawg</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">)</span> <span class="p">)</span> <span class="n">DawgTraverseLexiconRecurse</span><span class="p">(</span><span class="n">TheDawg</span><span class="p">,</span>
    <span class="n">PassOffIndex</span><span class="p">,</span> <span class="n">FillThisPosition</span><span class="p">,</span> <span class="n">WorkingString</span><span class="p">,</span> <span class="n">TheCount</span><span class="p">,</span> <span class="n">TheStream</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Move through "ThisDawg" lexicon, and print the words into "ThisStream".</span>
<span class="kt">void</span> <span class="nf">DawgTraverseLexicon</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ThisDawg</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">ThisStream</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">BufferWord</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">WordCounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">WordCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Include the Windows Carriage Return char.</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">ThisStream</span><span class="p">,</span> <span class="s">"This is the lexicon contained in the file |%s|.</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DAWG_DATA</span><span class="p">);</span>
    <span class="n">DawgTraverseLexiconRecurse</span><span class="p">(</span><span class="n">ThisDawg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BufferWord</span><span class="p">,</span> <span class="n">WordCounter</span><span class="p">,</span> <span class="n">ThisStream</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">BufferWord</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">WordCounter</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This function is the core component of this program.</span>
<span class="c1">// It requires that "UnusedChars" be in alphabetical order because the tradition Dawg is a list based structure.</span>
<span class="kt">void</span> <span class="nf">DawgAnagrammerRecurse</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">CurrentIndex</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ToyWithMe</span><span class="p">,</span>
 <span class="kt">int</span> <span class="n">FillThisPosition</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">UnusedChars</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SizeOfBank</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ForTheCounter</span><span class="p">,</span> <span class="n">Bool</span> <span class="n">WildCard</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">PreviousChar</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">CurrentChar</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">TempIndex</span> <span class="o">=</span> <span class="n">DAWG_CHILD</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">);</span>

    <span class="n">ToyWithMe</span><span class="p">[</span><span class="n">FillThisPosition</span><span class="p">]</span> <span class="o">=</span> <span class="n">DAWG_LETTER</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">WildCard</span><span class="o">?</span> <span class="n">LOWER_IT</span><span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">DAWG_END_OF_WORD</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ForTheCounter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">ToyWithMe</span><span class="p">[</span><span class="n">FillThisPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"|%4d| - |%-15s|%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">ForTheCounter</span><span class="p">,</span> <span class="n">ToyWithMe</span><span class="p">,</span> <span class="n">SizeOfBank</span><span class="o">?</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="o">:</span> <span class="s">"--&gt; TRUE ANAGRAM"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">SizeOfBank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">TempIndex</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">SizeOfBank</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">CurrentChar</span> <span class="o">=</span> <span class="n">UnusedChars</span><span class="p">[</span><span class="n">X</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentChar</span> <span class="o">==</span> <span class="n">PreviousChar</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentChar</span> <span class="o">==</span> <span class="n">WILD_CARD</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">REMOVE_CHAR_FROM_STRING</span><span class="p">(</span><span class="n">UnusedChars</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">SizeOfBank</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">TempIndex</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">DawgAnagrammerRecurse</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">,</span> <span class="n">ToyWithMe</span><span class="p">,</span> <span class="n">FillThisPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">UnusedChars</span><span class="p">,</span> <span class="n">SizeOfBank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ForTheCounter</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
                    <span class="n">TempIndex</span> <span class="o">=</span> <span class="n">DAWG_NEXT</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">INSERT_CHAR_IN_STRING</span><span class="p">(</span><span class="n">UnusedChars</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">CurrentChar</span><span class="p">,</span> <span class="n">SizeOfBank</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
                <span class="n">TempIndex</span> <span class="o">=</span> <span class="n">DAWG_CHILD</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">do</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentChar</span> <span class="o">==</span> <span class="n">DAWG_LETTER</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">REMOVE_CHAR_FROM_STRING</span><span class="p">(</span><span class="n">UnusedChars</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">SizeOfBank</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
                        <span class="n">DawgAnagrammerRecurse</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">,</span> <span class="n">ToyWithMe</span><span class="p">,</span> <span class="n">FillThisPosition</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">UnusedChars</span><span class="p">,</span> <span class="n">SizeOfBank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ForTheCounter</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
                        <span class="n">INSERT_CHAR_IN_STRING</span><span class="p">(</span><span class="n">UnusedChars</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">CurrentChar</span><span class="p">,</span> <span class="n">SizeOfBank</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
                        <span class="n">TempIndex</span> <span class="o">=</span> <span class="n">DAWG_NEXT</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentChar</span> <span class="o">&lt;</span> <span class="n">DAWG_LETTER</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">)</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">TempIndex</span> <span class="o">=</span> <span class="n">DAWG_NEXT</span><span class="p">(</span><span class="n">DawgOfWar</span><span class="p">,</span> <span class="n">TempIndex</span><span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">TempIndex</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">PreviousChar</span> <span class="o">=</span> <span class="n">CurrentChar</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function uses "MasterDawg" to determine the words that can be made from the letters in "CharBank".</span>
<span class="c1">// The words will be displayed in alphabetical order according to "CharacterSet[]".</span>
<span class="c1">// The return value is the total number of words found.</span>
<span class="kt">int</span> <span class="nf">DawgAnagrammer</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">MasterDawg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">CharBank</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">BankSize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">CharBank</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ForTheCount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">TheWordSoFar</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">LettersToWorkWith</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MAX_INPUT</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">));</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">PreviousChar</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">CurrentChar</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">NumberOfLetters</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">CurrentEntryNode</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">,</span> <span class="n">CharBank</span><span class="p">);</span>
    <span class="n">Alphabetize</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">);</span>
    <span class="n">NumberOfLetters</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ForTheCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">BankSize</span><span class="p">;</span> <span class="n">X</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">CurrentChar</span> <span class="o">=</span> <span class="n">LettersToWorkWith</span><span class="p">[</span><span class="n">X</span><span class="p">];</span>
        <span class="c1">// Move to the next letter if we have already processed the "CurrentChar".</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentChar</span> <span class="o">==</span> <span class="n">PreviousChar</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentChar</span> <span class="o">==</span> <span class="n">WILD_CARD</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">REMOVE_CHAR_FROM_STRING</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">NumberOfLetters</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_CHARACTER_SET</span><span class="p">;</span> <span class="n">Y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">EntryNodeIndex</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">DawgAnagrammerRecurse</span><span class="p">(</span><span class="n">MasterDawg</span><span class="p">,</span> <span class="n">EntryNodeIndex</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">TheWordSoFar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LettersToWorkWith</span><span class="p">,</span>
                    <span class="n">NumberOfLetters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ForTheCount</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">INSERT_CHAR_IN_STRING</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">CurrentChar</span><span class="p">,</span> <span class="n">NumberOfLetters</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
            <span class="n">PreviousChar</span> <span class="o">=</span> <span class="n">CurrentChar</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Make sure not to enter the graph if NO words begin with "CurrentChar".</span>
        <span class="n">CurrentEntryNode</span> <span class="o">=</span> <span class="n">EntryNodeIndex</span><span class="p">[</span><span class="n">CharToIndexConversion</span><span class="p">(</span><span class="n">CurrentChar</span><span class="p">)];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">CurrentEntryNode</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">PreviousChar</span> <span class="o">=</span> <span class="n">CurrentChar</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">REMOVE_CHAR_FROM_STRING</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">NumberOfLetters</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
        <span class="n">DawgAnagrammerRecurse</span><span class="p">(</span><span class="n">MasterDawg</span><span class="p">,</span> <span class="n">CurrentEntryNode</span><span class="p">,</span> <span class="n">TheWordSoFar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LettersToWorkWith</span><span class="p">,</span>
        <span class="n">NumberOfLetters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ForTheCount</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
        <span class="n">INSERT_CHAR_IN_STRING</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">CurrentChar</span><span class="p">,</span> <span class="n">NumberOfLetters</span> <span class="o">-</span> <span class="n">X</span><span class="p">);</span>
        <span class="n">PreviousChar</span> <span class="o">=</span> <span class="n">CurrentChar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Result</span> <span class="o">=</span> <span class="o">*</span><span class="n">ForTheCount</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ForTheCount</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">TheWordSoFar</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">LettersToWorkWith</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">NumberOfNodes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">TheDawgArray</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">Lexicon</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">WordList</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">DecisionInput</span><span class="p">;</span>
    <span class="n">Bool</span> <span class="n">FetchData</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">FirstChar</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">InputSize</span><span class="p">;</span>

    <span class="n">DecisionInput</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MAX_INPUT</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="n">Lexicon</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">DAWG_DATA</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
    <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NumberOfNodes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Lexicon</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  The lexicon DAWG contains |%d| nodes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfNodes</span><span class="p">);</span>
    <span class="n">TheDawgArray</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">NumberOfNodes</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">TheDawgArray</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">NumberOfNodes</span><span class="p">,</span> <span class="n">Lexicon</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">Lexicon</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">  </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s"> has been read into memory.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DAWG_DATA</span><span class="p">);</span>

    <span class="c1">// This program relies on a compressed lexicon data file,</span>
    <span class="c1">// so allow the user to see a readable word list in an output file.</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">FetchData</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Would you like to print the Dawg word list into a text file?(Y/N):  "</span><span class="p">);</span>
        <span class="n">fgets</span><span class="p">(</span><span class="n">DecisionInput</span><span class="p">,</span> <span class="n">MAX_INPUT</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
        <span class="n">FirstChar</span> <span class="o">=</span> <span class="n">DecisionInput</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">FirstChar</span> <span class="o">==</span> <span class="sc">'Y'</span> <span class="o">||</span> <span class="n">FirstChar</span> <span class="o">==</span> <span class="sc">'y'</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">WordList</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">WORD_LIST_OUTPUT</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
            <span class="n">DawgTraverseLexicon</span><span class="p">(</span><span class="n">TheDawgArray</span><span class="p">,</span> <span class="n">WordList</span><span class="p">);</span>
            <span class="n">fclose</span><span class="p">(</span><span class="n">WordList</span><span class="p">);</span>
            <span class="n">FetchData</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">FirstChar</span> <span class="o">==</span> <span class="sc">'N'</span> <span class="o">||</span> <span class="n">FirstChar</span> <span class="o">==</span> <span class="sc">'n'</span> <span class="p">)</span> <span class="n">FetchData</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FetchData</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

    <span class="c1">// Now the user can enter strings of letters for anagramming, to see the words that can be made from them.</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">FetchData</span> <span class="o">==</span> <span class="n">TRUE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Enter anagram letters ( At least 2 letters) - (WildCard = ?):  "</span><span class="p">);</span>
        <span class="n">fgets</span><span class="p">(</span><span class="n">DecisionInput</span><span class="p">,</span> <span class="n">MAX_INPUT</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
        <span class="n">CUT_OFF_NEW_LINE</span><span class="p">(</span><span class="n">DecisionInput</span><span class="p">);</span>
        <span class="n">MakeMeAllCapital</span><span class="p">(</span><span class="n">DecisionInput</span><span class="p">);</span>
        <span class="n">RemoveIllegalChars</span><span class="p">(</span><span class="n">DecisionInput</span><span class="p">);</span>
        <span class="n">InputSize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">DecisionInput</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">InputSize</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">This is the set of letters that you just input |%s|.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DecisionInput</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">|%d| Words were found in the lexicon Dawg.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DawgAnagrammer</span><span class="p">(</span><span class="n">TheDawgArray</span><span class="p">,</span> <span class="n">DecisionInput</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">FetchData</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Thank you for testing the new Blitzkrieg DAWG encoding.  GAME OVER.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contact"><a class="anchor" href="#contact"></a>Contact Information</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Contact: JohnPaul Adamovsky&#8201;&#8212;&#8201;(&#160;<a href="mailto:logarithm69@hotmail.com">logarithm69@hotmail.com</a>&#160;)&#8201;&#8212;&#8201;Please feel free to ask me questions.</p>
</div>
<div class="paragraph">
<p>Phone: (416) 231-7577</p>
</div>
<div class="paragraph">
<p><strong>All The Very Best,</strong></p>
</div>
<div class="paragraph">
<p>JohnPaul Adamovsky</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>